{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ISO Week Date","text":"<p>iso-week-date is a toolkit to work with strings representing ISO Week date in two formats, namely:</p> <ul> <li>Week format YYYY-WNN (date format %Y-W%V)</li> <li>Week date format YYYY-WNN-D (date format %Y-W%V-%u)</li> </ul> <p>where YYYY represents the year, W is a literal, NN represents the week number, and D represents the day of the week.</p> <p>In a nutshell it provides:</p> <ul> <li><code>IsoWeek</code> and <code>IsoWeekDate</code> classes that implement a series of methods to work with ISO Week (Date) formats directly, avoiding the pitfalls of going back and forth between string, date and datetime python objects.</li> <li>pandas and polars functionalities (and namespaces) to work with series of ISO Week dates.</li> <li>pydantic compatible types, as described in their docs section on how to customize validation with <code>__get_pydantic_core_schema__</code></li> </ul> <p>Documentation | Source Code | Issue Tracker</p>"},{"location":"#installation","title":"Installation","text":"<p>TL;DR: you can install the package with pip:</p> <pre><code>python -m pip install iso-week-date\n</code></pre> <p>For more information please refer to the installation section.</p>"},{"location":"#usage","title":"Usage","text":"<p>To get started with <code>IsoWeek</code> and <code>IsoWeekDate</code> classes please refer to the quickstart section.</p> <p>To check examples on how to work with pandas and polars functionalities please refer to the dataframe modules section.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Please read the contributing guidelines in the documentation site.</p>"},{"location":"#license","title":"License","text":"<p>The project has a MIT Licence.</p>"},{"location":"contribute/","title":"Contributing","text":""},{"location":"contribute/#guidelines","title":"Guidelines","text":"<p>We welcome contributions to the library! If you have a bug fix or new feature that you would like to contribute, please follow the steps below:</p> <ol> <li>Fork the repository on GitHub.</li> <li>Clone the repository to your local machine.</li> <li>Create a new branch for your bug fix or feature.</li> <li>Make your changes and test them thoroughly, making sure that it passes all current tests.</li> <li>Commit your changes and push the branch to your fork.</li> <li>Open a pull request on the main repository.</li> </ol>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the project's code of conduct, which is based on the Contributor Covenant.</p>"},{"location":"contribute/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in the library, please report it by opening an issue on GitHub. Be sure to include the version of the library you're using, as well as any error messages or tracebacks and a reproducible example.</p>"},{"location":"contribute/#requesting-features","title":"Requesting Features","text":"<p>If you have a suggestion for a new feature, please open an issue on GitHub. Be sure to explain the problem that you're trying to solve and how you think the feature would solve it.</p>"},{"location":"contribute/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>When submitting a pull request, please make sure that you've followed the steps above and that your code has been thoroughly tested. Also, be sure to include a brief summary of the changes you've made and a reference to any issues that your pull request resolves.</p>"},{"location":"contribute/#code-formatting","title":"Code formatting","text":"<p>iso-week-date uses ruff as linter and formatter:</p> with makewithout make <pre><code>make lint\n</code></pre> <pre><code>ruff check iso_week_date tests --fix\nruff format iso_week_date tests\n</code></pre> <p>As part of the checks on pull requests, it is checked whether the code follows those standards. To ensure that the standard is met, it is recommended to install pre-commit hooks:</p> <pre><code>python -m pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contribute/#developing","title":"Developing","text":"<p>Let's suppose that you already did steps 1-3 from the above list, now you should install the library and its developing dependencies  in editable way.</p> <p>First move into the repo folder: <code>cd iso-week-date</code>.</p> <p>Then:</p> with makewithout make <pre><code>make init-dev\n</code></pre> <pre><code>pip install -e \".[all-dev]\" --no-cache-dir\npre-commit install\n</code></pre> <p>Now you are ready to proceed with all the changes you want to!</p>"},{"location":"contribute/#testing","title":"Testing","text":"<p>Once you are done with changes, you should:</p> <ul> <li>add tests for the new features in the <code>/tests</code> folder</li> <li> <p>make sure that new features do not break existing codebase by running tests:</p> with makewithout make <pre><code>make test\n</code></pre> <pre><code>pytest tests -vv\n</code></pre> </li> </ul>"},{"location":"contribute/#docs","title":"Docs","text":"<p>The documentation is generated using mkdocs-material, the API part uses mkdocstrings.</p> <p>If a breaking feature is developed, then we suggest to update documentation in the <code>/docs</code> folder as well, in order to describe how this can be used from a user perspective.</p>"},{"location":"installation/","title":"Installation","text":"<p>iso-week-date is published as a Python package on pypi, and it can be installed with pip, or directly from source using git, or with a local clone:</p> pip (pypi)source/gitlocal clone <pre><code>python -m pip install iso-week-date\n</code></pre> <pre><code>python -m pip install git+https://github.com/FBruzzesi/iso-week-date.git\n</code></pre> <pre><code>git clone https://github.com/FBruzzesi/iso-week-date.git\ncd iso-week-date\npython -m pip install .\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li>To work with <code>IsoWeek</code> and <code>IsoWeekDate</code> classes, no additional dependencies are required.</li> <li> <p>pandas, polars  and/or pydantic functionalities require the installation of the respective libraries.</p> pandaspolarspydantic <pre><code>python -m pip install \"pandas&gt;=1.0.0\"\npython -m pip install \"iso-week-date[pandas]\"\n</code></pre> <pre><code>python pip install \"polars&gt;=0.18.0\"\npython pip install \"iso-week-date[polars]\"\n</code></pre> <pre><code>python pip install \"pydantic&gt;=2.4.0\"\npython pip install \"iso-week-date[pydantic]\"\n</code></pre> </li> </ul>"},{"location":"api/baseisoweek/","title":"<code>BaseIsoWeek</code> class","text":""},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek","title":"<code>iso_week_date.base.BaseIsoWeek</code>","text":"<p>             Bases: <code>ABC</code>, <code>ComparatorMixin</code>, <code>ConverterMixin</code>, <code>ParserMixin</code></p> <p>Base abstract class for <code>IsoWeek</code> and <code>IsoWeekDate</code> classes.</p> <p>It defines the common interface for both classes and implements the common methods between them.</p> <p>Attributes:</p> Name Type Description <code>value_</code> <code>str</code> <p>stores the string value representing the iso-week date in the <code>_format</code> format.</p> <code>offset_</code> <code>timedelta</code> <p>class variable, stores the offset to be used when converting to and from <code>datetime</code> and <code>date</code> objects.</p> <code>_pattern</code> <code>Pattern</code> <p>class variable, stores the regex pattern to validate iso-week string format. Semiprivate, do not use it directly.</p> <code>_format</code> <code>str</code> <p>class variable, stores the string format of the iso-week date. Semiprivate, do not use it directly.</p> <code>_date_format</code> <code>str</code> <p>class variable, stores the string format with datetime conventions. Semiprivate, do not use it directly.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>class BaseIsoWeek(ABC, ComparatorMixin, ConverterMixin, ParserMixin):\n    \"\"\"Base abstract class for `IsoWeek` and `IsoWeekDate` classes.\n\n    It defines the common interface for both classes and implements the common methods between them.\n\n    Attributes:\n        value_: stores the string value representing the iso-week date in the `_format` format.\n        offset_: class variable, stores the offset to be used when converting to and from `datetime` and `date` objects.\n        _pattern: class variable, stores the regex pattern to validate iso-week string format. Semiprivate, do not use\n            it directly.\n        _format: class variable, stores the string format of the iso-week date. Semiprivate, do not use it directly.\n        _date_format: class variable, stores the string format with datetime conventions. Semiprivate, do not use it\n            directly.\n    \"\"\"\n\n    offset_: ClassVar[timedelta] = timedelta(days=0)\n\n    _pattern: ClassVar[re.Pattern]\n    _format: ClassVar[str]\n    _date_format: ClassVar[str]\n\n    __slots__ = (\"value_\",)\n\n    def __init__(self: Self, value: str) -&gt; None:\n        \"\"\"Initializes `BaseIsoWeek` object from iso-week string.\n\n        Arguments:\n            value: ISO Week string to initialize `BaseIsoWeek` object, must match the `_pattern` pattern of the class,\n                otherwise a `ValueError` will be raised.\n\n        Raises:\n            ValueError: If `value` does not match the `_pattern` pattern of the class.\n        \"\"\"\n        self.value_: str = self._validate(value)\n\n    @classmethod\n    def _validate(cls: Type[Self], value: str) -&gt; str:\n        \"\"\"Validates iso-week string format against `_pattern`.\"\"\"\n        _match = re.match(cls._pattern, value)\n\n        if not _match:\n            raise ValueError(format_err_msg(cls._format, value))\n\n        year, week = int(_match.group(1)), int(_match.group(2)[1:])\n\n        if weeks_of_year(year) &lt; week:\n            msg = f\"Invalid week number. Year {year} has only {weeks_of_year(year)} weeks.\"\n            raise ValueError(msg)\n\n        return value\n\n    def __repr__(self: Self) -&gt; str:\n        \"\"\"Custom representation.\"\"\"\n        return f\"{self.name}({self.value_}) with offset {self.offset_}\"\n\n    def __str__(self: Self) -&gt; str:\n        \"\"\"String conversion operator, returns iso-week string value ignoring offset.\"\"\"\n        return self.value_\n\n    @classproperty\n    def _compact_pattern(cls: Type[IsoWeekProtocol]) -&gt; re.Pattern:  # noqa: N805\n        \"\"\"Returns compiled compact pattern.\"\"\"\n        return re.compile(cls._pattern.pattern.replace(\")-(\", \")(\"))\n\n    @classproperty\n    def _compact_format(cls: Type[IsoWeekProtocol]) -&gt; str:  # noqa: N805\n        \"\"\"Returns compact format as string.\"\"\"\n        return cls._format.replace(\"-\", \"\")\n\n    @property\n    def name(self: Self) -&gt; str:\n        \"\"\"Returns class name.\"\"\"\n        return self.__class__.__name__\n\n    @property\n    def year(self: Self) -&gt; int:\n        \"\"\"Returns year number as integer.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek, IsoWeekDate\n\n        IsoWeek(\"2023-W01\").year # 2023\n        IsoWeekDate(\"2023-W01-1\").year # 2023\n        ```\n        \"\"\"\n        return int(self.value_[:4])\n\n    @property\n    def week(self: Self) -&gt; int:\n        \"\"\"Returns week number as integer.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek, IsoWeekDate\n\n        IsoWeek(\"2023-W01\").week  # 1\n        IsoWeekDate(\"2023-W01-1\").week  # 1\n        ```\n        \"\"\"\n        return int(self.value_[6:8])\n\n    @property\n    def quarter(self: Self) -&gt; int:\n        \"\"\"Returns quarter number as integer.\n\n        The first three quarters have 13 weeks, while the last one has either 13 or 14 weeks depending on the year:\n\n        - Q1: weeks from 1 to 13\n        - Q2: weeks from 14 to 26\n        - Q3: weeks from 27 to 39\n        - Q4: weeks from 40 to 52 (or 53 if applicable)\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek, IsoWeekDate\n\n        IsoWeek(\"2023-W01\").quarter  # 1\n        IsoWeekDate(\"2023-W52-1\").quarter  # 4\n        ```\n        \"\"\"\n        return min((self.week - 1) // 13 + 1, 4)\n\n    @overload\n    def __add__(self: Self, other: Union[int, timedelta]) -&gt; Self: ...  # pragma: no cover\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Iterable[Union[int, timedelta]],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n    ) -&gt; Union[Self, Generator[Self, None, None]]: ...  # pragma: no cover\n\n    @abstractmethod\n    def __add__(\n        self: Self,\n        other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n    ) -&gt; Union[Self, Generator[Self, None, None]]:  # pragma: no cover\n        \"\"\"Implementation of addition operator.\"\"\"\n        ...\n\n    @overload\n    def __sub__(self: Self, other: Union[int, timedelta]) -&gt; Self: ...  # pragma: no cover\n\n    @overload\n    def __sub__(self: Self, other: Self) -&gt; int: ...  # pragma: no cover\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Iterable[Union[int, timedelta]],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __sub__(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n    ) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]: ...  # pragma: no cover\n\n    @abstractmethod\n    def __sub__(\n        self: Self,\n        other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n    ) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]:  # pragma: no cover\n        \"\"\"Implementation of subtraction operator.\"\"\"\n        ...\n\n    def __next__(self: Self) -&gt; Self:\n        \"\"\"Implementation of next operator.\"\"\"\n        return self + 1\n\n    @overload\n    @classmethod\n    def range(\n        cls: Type[Self],\n        start: BaseIsoWeek_T,\n        end: BaseIsoWeek_T,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: Literal[True],\n    ) -&gt; Generator[str, None, None]: ...  # pragma: no cover\n\n    @overload\n    @classmethod\n    def range(\n        cls: Type[Self],\n        start: BaseIsoWeek_T,\n        end: BaseIsoWeek_T,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: Literal[False],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    @classmethod\n    def range(\n        cls: Type[Self],\n        start: BaseIsoWeek_T,\n        end: BaseIsoWeek_T,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: bool = True,\n    ) -&gt; Generator[Union[str, Self], None, None]: ...  # pragma: no cover\n\n    @classmethod\n    def range(\n        cls: Type[Self],\n        start: BaseIsoWeek_T,\n        end: BaseIsoWeek_T,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: bool = True,\n    ) -&gt; Generator[Union[str, Self], None, None]:\n        \"\"\"Generates `BaseIsoWeek` (or `str`) between `start` and `end` values with given `step`.\n\n        `inclusive` parameter can be used to control inclusion of `start` and/or `end` week values.\n\n        If `as_str` is flagged as `True`, it will return str values, otherwise it will return `BaseIsoWeek` objects.\n\n        Arguments:\n            start: Starting value. It can be `BaseIsoWeek`, `date`, `datetime` or `str`.\n            end: Ending value. It can be `BaseIsoWeek`, `date`, `datetime` or `str`.\n            step: Step between generated values, must be positive integer.\n            inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n            as_str: Whether to return `str` or `BaseIsoWeek` object.\n\n        Returns:\n            Generator of `IsoWeeks`/`str` between `start` and `end` values with given `step`.\n\n        Raises:\n            ValueError: If any of the following conditions is met:\n\n                - `start &gt; end`.\n                - `inclusive` not one of \"both\", \"left\", \"right\" or \"neither\".\n                - `step` is not strictly positive.\n            TypeError: If `step` is not an int.\n\n        Examples:\n        ```python\n        from iso_week_date import IsoWeek\n\n        tuple(IsoWeek.range(\n            start=\"2023-W01\",\n            end=\"2023-W07\",\n            step=2,\n            inclusive=\"both\",\n            as_str=True)\n            )\n        # ('2023-W01', '2023-W03', '2023-W05', '2023-W07')\n        ```\n        \"\"\"\n        _start = cls._cast(start)\n        _end = cls._cast(end)\n\n        if _start &gt; _end:\n            msg = f\"`start` must be before `end` value, found: {_start} &gt; {_end}\"\n            raise ValueError(msg)\n\n        if not isinstance(step, int):\n            msg = f\"`step` must be integer, found {type(step)}\"\n            raise TypeError(msg)\n\n        if step &lt; 1:\n            msg = f\"`step` value must be greater than or equal to 1, found {step}\"\n            raise ValueError(msg)\n\n        if inclusive not in _inclusive_values:\n            msg = f\"Invalid `inclusive` value. Must be one of {_inclusive_values}\"\n            raise ValueError(msg)\n\n        _delta = _end - _start\n        range_start = 0 if inclusive in (\"both\", \"left\") else 1\n        range_end = _delta + 1 if inclusive in (\"both\", \"right\") else _delta\n\n        weeks_range: Generator[Union[str, Self], None, None] = (\n            (_start + i).to_string() if as_str else _start + i for i in range(range_start, range_end, step)\n        )\n\n        return weeks_range\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns class name.</p>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.quarter","title":"<code>quarter: int</code>  <code>property</code>","text":"<p>Returns quarter number as integer.</p> <p>The first three quarters have 13 weeks, while the last one has either 13 or 14 weeks depending on the year:</p> <ul> <li>Q1: weeks from 1 to 13</li> <li>Q2: weeks from 14 to 26</li> <li>Q3: weeks from 27 to 39</li> <li>Q4: weeks from 40 to 52 (or 53 if applicable)</li> </ul> <p>Examples: <pre><code>from iso_week_date import IsoWeek, IsoWeekDate\n\nIsoWeek(\"2023-W01\").quarter  # 1\nIsoWeekDate(\"2023-W52-1\").quarter  # 4\n</code></pre></p>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.week","title":"<code>week: int</code>  <code>property</code>","text":"<p>Returns week number as integer.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek, IsoWeekDate\n\nIsoWeek(\"2023-W01\").week  # 1\nIsoWeekDate(\"2023-W01-1\").week  # 1\n</code></pre></p>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.year","title":"<code>year: int</code>  <code>property</code>","text":"<p>Returns year number as integer.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek, IsoWeekDate\n\nIsoWeek(\"2023-W01\").year # 2023\nIsoWeekDate(\"2023-W01-1\").year # 2023\n</code></pre></p>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.__add__","title":"<code>__add__(other)</code>  <code>abstractmethod</code>","text":"<p>Implementation of addition operator.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>@abstractmethod\ndef __add__(\n    self: Self,\n    other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n) -&gt; Union[Self, Generator[Self, None, None]]:  # pragma: no cover\n    \"\"\"Implementation of addition operator.\"\"\"\n    ...\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.__init__","title":"<code>__init__(value)</code>","text":"<p>Initializes <code>BaseIsoWeek</code> object from iso-week string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>ISO Week string to initialize <code>BaseIsoWeek</code> object, must match the <code>_pattern</code> pattern of the class, otherwise a <code>ValueError</code> will be raised.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> does not match the <code>_pattern</code> pattern of the class.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>def __init__(self: Self, value: str) -&gt; None:\n    \"\"\"Initializes `BaseIsoWeek` object from iso-week string.\n\n    Arguments:\n        value: ISO Week string to initialize `BaseIsoWeek` object, must match the `_pattern` pattern of the class,\n            otherwise a `ValueError` will be raised.\n\n    Raises:\n        ValueError: If `value` does not match the `_pattern` pattern of the class.\n    \"\"\"\n    self.value_: str = self._validate(value)\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.__next__","title":"<code>__next__()</code>","text":"<p>Implementation of next operator.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>def __next__(self: Self) -&gt; Self:\n    \"\"\"Implementation of next operator.\"\"\"\n    return self + 1\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.__repr__","title":"<code>__repr__()</code>","text":"<p>Custom representation.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>def __repr__(self: Self) -&gt; str:\n    \"\"\"Custom representation.\"\"\"\n    return f\"{self.name}({self.value_}) with offset {self.offset_}\"\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.__str__","title":"<code>__str__()</code>","text":"<p>String conversion operator, returns iso-week string value ignoring offset.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>def __str__(self: Self) -&gt; str:\n    \"\"\"String conversion operator, returns iso-week string value ignoring offset.\"\"\"\n    return self.value_\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.__sub__","title":"<code>__sub__(other)</code>  <code>abstractmethod</code>","text":"<p>Implementation of subtraction operator.</p> Source code in <code>iso_week_date/base.py</code> <pre><code>@abstractmethod\ndef __sub__(\n    self: Self,\n    other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]:  # pragma: no cover\n    \"\"\"Implementation of subtraction operator.\"\"\"\n    ...\n</code></pre>"},{"location":"api/baseisoweek/#iso_week_date.base.BaseIsoWeek.range","title":"<code>range(start, end, *, step=1, inclusive='both', as_str=True)</code>  <code>classmethod</code>","text":"<p>Generates <code>BaseIsoWeek</code> (or <code>str</code>) between <code>start</code> and <code>end</code> values with given <code>step</code>.</p> <p><code>inclusive</code> parameter can be used to control inclusion of <code>start</code> and/or <code>end</code> week values.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return str values, otherwise it will return <code>BaseIsoWeek</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>BaseIsoWeek_T</code> <p>Starting value. It can be <code>BaseIsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <code>end</code> <code>BaseIsoWeek_T</code> <p>Ending value. It can be <code>BaseIsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <code>step</code> <code>int</code> <p>Step between generated values, must be positive integer.</p> <code>1</code> <code>inclusive</code> <code>Literal['both', 'left', 'right', 'neither']</code> <p>Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".</p> <code>'both'</code> <code>as_str</code> <code>bool</code> <p>Whether to return <code>str</code> or <code>BaseIsoWeek</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>Generator[Union[str, Self], None, None]</code> <p>Generator of <code>IsoWeeks</code>/<code>str</code> between <code>start</code> and <code>end</code> values with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the following conditions is met:</p> <ul> <li><code>start &gt; end</code>.</li> <li><code>inclusive</code> not one of \"both\", \"left\", \"right\" or \"neither\".</li> <li><code>step</code> is not strictly positive.</li> </ul> <code>TypeError</code> <p>If <code>step</code> is not an int.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek\n\ntuple(IsoWeek.range(\n    start=\"2023-W01\",\n    end=\"2023-W07\",\n    step=2,\n    inclusive=\"both\",\n    as_str=True)\n    )\n# ('2023-W01', '2023-W03', '2023-W05', '2023-W07')\n</code></pre></p> Source code in <code>iso_week_date/base.py</code> <pre><code>@classmethod\ndef range(\n    cls: Type[Self],\n    start: BaseIsoWeek_T,\n    end: BaseIsoWeek_T,\n    *,\n    step: int = 1,\n    inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n    as_str: bool = True,\n) -&gt; Generator[Union[str, Self], None, None]:\n    \"\"\"Generates `BaseIsoWeek` (or `str`) between `start` and `end` values with given `step`.\n\n    `inclusive` parameter can be used to control inclusion of `start` and/or `end` week values.\n\n    If `as_str` is flagged as `True`, it will return str values, otherwise it will return `BaseIsoWeek` objects.\n\n    Arguments:\n        start: Starting value. It can be `BaseIsoWeek`, `date`, `datetime` or `str`.\n        end: Ending value. It can be `BaseIsoWeek`, `date`, `datetime` or `str`.\n        step: Step between generated values, must be positive integer.\n        inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n        as_str: Whether to return `str` or `BaseIsoWeek` object.\n\n    Returns:\n        Generator of `IsoWeeks`/`str` between `start` and `end` values with given `step`.\n\n    Raises:\n        ValueError: If any of the following conditions is met:\n\n            - `start &gt; end`.\n            - `inclusive` not one of \"both\", \"left\", \"right\" or \"neither\".\n            - `step` is not strictly positive.\n        TypeError: If `step` is not an int.\n\n    Examples:\n    ```python\n    from iso_week_date import IsoWeek\n\n    tuple(IsoWeek.range(\n        start=\"2023-W01\",\n        end=\"2023-W07\",\n        step=2,\n        inclusive=\"both\",\n        as_str=True)\n        )\n    # ('2023-W01', '2023-W03', '2023-W05', '2023-W07')\n    ```\n    \"\"\"\n    _start = cls._cast(start)\n    _end = cls._cast(end)\n\n    if _start &gt; _end:\n        msg = f\"`start` must be before `end` value, found: {_start} &gt; {_end}\"\n        raise ValueError(msg)\n\n    if not isinstance(step, int):\n        msg = f\"`step` must be integer, found {type(step)}\"\n        raise TypeError(msg)\n\n    if step &lt; 1:\n        msg = f\"`step` value must be greater than or equal to 1, found {step}\"\n        raise ValueError(msg)\n\n    if inclusive not in _inclusive_values:\n        msg = f\"Invalid `inclusive` value. Must be one of {_inclusive_values}\"\n        raise ValueError(msg)\n\n    _delta = _end - _start\n    range_start = 0 if inclusive in (\"both\", \"left\") else 1\n    range_end = _delta + 1 if inclusive in (\"both\", \"right\") else _delta\n\n    weeks_range: Generator[Union[str, Self], None, None] = (\n        (_start + i).to_string() if as_str else _start + i for i in range(range_start, range_end, step)\n    )\n\n    return weeks_range\n</code></pre>"},{"location":"api/isoweek/","title":"<code>IsoWeek</code> class","text":""},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek","title":"<code>iso_week_date.isoweek.IsoWeek</code>","text":"<p>             Bases: <code>BaseIsoWeek</code></p> <p>Represents ISO Week date in the  YYYY-WNN format.</p> <p>The class implements methods and functionalities to work directly with iso week format and avoid moving back and forth between <code>date</code>, <code>datetime</code> and <code>str</code> objects.</p> <p>Attributes:</p> Name Type Description <code>value_</code> <p>iso-week string of format \"YYYY-WNN\" where:</p> <ul> <li>YYYY is between 0001 and 9999</li> <li>W is a literal character</li> <li>NN is between 01 and 53</li> </ul> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>class IsoWeek(BaseIsoWeek):\n    \"\"\"Represents [ISO Week date](https://en.wikipedia.org/wiki/ISO_week_date) in the  _YYYY-WNN_ format.\n\n    The class implements methods and functionalities to work directly with iso week format and avoid moving back and\n    forth between `date`, `datetime` and `str` objects.\n\n    Attributes:\n        value_: iso-week string of format \"YYYY-WNN\" where:\n\n            - YYYY is between 0001 and 9999\n            - W is a literal character\n            - NN is between 01 and 53\n    \"\"\"\n\n    _pattern = ISOWEEK_PATTERN\n\n    _format = ISOWEEK__FORMAT\n    _date_format = ISOWEEK__DATE_FORMAT\n\n    @property\n    def days(self: Self) -&gt; Tuple[date, ...]:\n        \"\"\"Returns tuple of days (as date) in the ISO week.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\").days  # (date(2023, 1, 2), ..., date(2023, 1, 8))\n        ```\n        \"\"\"\n        return tuple(self.to_date(weekday) for weekday in range(1, 8))\n\n    def nth(self: Self, n: int) -&gt; date:\n        \"\"\"Returns Nth day of the week using the ISO weekday numbering convention (1=First, 2=Second, ..., 7=Last day).\n\n        !!! info\n            Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n        Arguments:\n            n: Day number between 1 and 7.\n\n        Returns:\n            `date` object representing the Nth day of the week.\n\n        Raises:\n            TypeError: If `n` is not an integer.\n            ValueError: If `n` is not between 1 and 7.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\").nth(1)  # date(2023, 1, 2)\n        IsoWeek(\"2023-W01\").nth(7)  # date(2023, 1, 8)\n        ```\n        \"\"\"\n        if not isinstance(n, int):\n            msg = f\"`n` must be an integer, found {type(n)}\"\n            raise TypeError(msg)\n        if n not in range(1, 8):\n            msg = f\"`n` must be between 1 and 7, found {n}\"\n            raise ValueError(msg)\n\n        return self.days[n - 1]\n\n    def to_datetime(self: Self, weekday: int = 1) -&gt; datetime:\n        \"\"\"Converts `IsoWeek` to `datetime` object with the given weekday.\n\n        If no weekday is provided then the first day of the week is used.\n\n        !!! info\n            Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n        Arguments:\n            weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n                is the last day of the week.\n\n        Returns:\n            `IsoWeek` value in `datetime` type with the given weekday.\n\n        Raises:\n            TypeError: If `weekday` is not an integer.\n            ValueError: If `weekday` is not between 1 and 7.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\").to_datetime()  # datetime.datetime(2023, 1, 2, 0, 0)\n        IsoWeek(\"2023-W01\").to_datetime(3)  # datetime.datetime(2023, 1, 4, 0, 0)\n        ```\n        \"\"\"\n        if not isinstance(weekday, int):\n            msg = f\"`weekday` must be an integer between 1 and 7, found {type(weekday)}\"\n            raise TypeError(msg)\n        if weekday not in range(1, 8):\n            msg = f\"Invalid `weekday`. Weekday must be between 1 and 7, found {weekday}\"\n            raise ValueError(msg)\n\n        return super()._to_datetime(f\"{self.value_}-{weekday}\")\n\n    def to_date(self: Self, weekday: int = 1) -&gt; date:\n        \"\"\"Converts `IsoWeek` to `date` object with the given `weekday`.\n\n        If no weekday is provided then the first day of the week is used.\n\n        !!! info\n            Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n        Arguments:\n            weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n                is the last day of the week.\n\n        Returns:\n            `IsoWeek` value in `date` type with the given weekday.\n\n        Raises:\n            TypeError: If `weekday` is not an integer.\n            ValueError: If `weekday` is not between 1 and 7.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\").to_date()  # datetime.date(2023, 1, 2)\n        IsoWeek(\"2023-W01\").to_date(3)  # datetime.date(2023, 1, 4)\n        ```\n        \"\"\"\n        return self.to_datetime(weekday).date()\n\n    @overload\n    def __add__(self: Self, other: Union[int, timedelta]) -&gt; Self: ...  # pragma: no cover\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Iterable[Union[int, timedelta]],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n    ) -&gt; Union[Self, Generator[Self, None, None]]: ...  # pragma: no cover\n\n    def __add__(\n        self: Self,\n        other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n    ) -&gt; Union[Self, Generator[Self, None, None]]:\n        \"\"\"Addition operation.\n\n        It supports addition with the following types:\n\n        - `int`: interpreted as number of weeks to be added to the `IsoWeek` value.\n        - `timedelta`: converts `IsoWeek` to datetime (first day of week), adds `timedelta` and converts back to\n            `IsoWeek` object.\n        - `Iterable` of `int` and/or `timedelta`: adds each element of the iterable to the `IsoWeek` value and returns\n            a generator of `IsoWeek` objects.\n\n        Arguments:\n            other: Object to add to `IsoWeek`.\n\n        Returns:\n            New `IsoWeek` or generator of `IsoWeek` object(s) with the result of the addition.\n\n        Raises:\n            TypeError: If `other` is not `int`, `timedelta` or `Iterable` of `int` and/or `timedelta`.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") + 1  # IsoWeek(\"2023-W02\")\n        IsoWeek(\"2023-W01\") + timedelta(weeks=2)  # IsoWeek(\"2023-W03\")\n        IsoWeek(\"2023-W01\") + timedelta(hours=1234) # IsoWeek(\"2023-W08\")\n\n        tuple(IsoWeek(\"2023-W01\") + (1,2,3)) # (IsoWeek(\"2023-W02\"), IsoWeek(\"2023-W03\"), IsoWeek(\"2023-W04\"))\n        ```\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() + timedelta(weeks=other))\n        elif isinstance(other, timedelta):\n            return self.from_datetime(self.to_datetime() + other)\n        elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta)) for _other in other):\n            return (self + _other for _other in other)\n        else:\n            msg = (\n                f\"Cannot add type {type(other)} to `IsoWeek`. \"\n                \"Addition is supported with `int` and `timedelta` types\",\n            )\n            raise TypeError(msg)\n\n    @overload\n    def __sub__(self: Self, other: Union[int, timedelta]) -&gt; Self: ...  # pragma: no cover\n\n    @overload\n    def __sub__(self: Self, other: Self) -&gt; int: ...  # pragma: no cover\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Iterable[Union[int, timedelta]],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __sub__(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n    ) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]: ...  # pragma: no cover\n\n    def __sub__(\n        self: Self,\n        other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n    ) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]:\n        \"\"\"Subtraction operation.\n\n        It supports subtraction with the following types:\n\n        - `int`: interpreted as number of weeks to be subtracted to the `IsoWeek` value.\n        - `timedelta`: converts `IsoWeek` to datetime (first day of week), subtract `timedelta` and converts back to\n            `IsoWeek` object.\n        - `IsoWeek`: will result in the difference between values in weeks (`int` type).\n        - `Iterable` of `int`, `timedelta` and/or `IsoWeek`: subtracts each element of the iterable to the `IsoWeek`.\n\n        Arguments:\n            other: Object to subtract to `IsoWeek`.\n\n        Returns:\n            Results from the subtraction, can be `int`, `IsoWeek` or Generator of `int` and/or `IsoWeek` depending\n                on the type of `other`.\n\n        Raises:\n            TypeError: If `other` is not `int`, `timedelta`, `IsoWeek` or `Iterable` of those types.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") - 1  # IsoWeek(\"2022-W52\")\n        IsoWeek(\"2023-W01\") - timedelta(weeks=2)  # IsoWeek(\"2022-W51\")\n        IsoWeek(\"2023-W01\") - timedelta(hours=1234)  # IsoWeek(\"2023-W45\")\n\n        tuple(IsoWeek(\"2023-W01\") - (1,2,3))  # (IsoWeek(\"2022-W52\"), IsoWeek(\"2022-W51\"), IsoWeek(\"2022-W50\"))\n\n        IsoWeek(\"2023-W01\") - IsoWeek(\"2022-W52\")  # 1\n        IsoWeek(\"2023-W01\") - IsoWeek(\"2022-W51\")  # 2\n        ```\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() - timedelta(weeks=other))\n        if isinstance(other, timedelta):\n            return self.from_datetime(self.to_datetime() - other)\n        elif isinstance(other, IsoWeek) and self.offset_ == other.offset_:\n            return (self.to_date() - other.to_date()).days // 7\n        elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta, IsoWeek)) for _other in other):\n            return (self - _other for _other in other)\n        else:\n            msg = (\n                f\"Cannot subtract type {type(other)} to `IsoWeek`. \"\n                \"Subtraction is supported with `int`, `timedelta` and `IsoWeek` types\"\n            )\n            raise TypeError(msg)\n\n    @overload\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: Literal[True],\n    ) -&gt; Generator[str, None, None]: ...  # pragma: no cover\n\n    @overload\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: Literal[False],\n    ) -&gt; Generator[IsoWeek, None, None]: ...  # pragma: no cover\n\n    @overload\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[Union[str, IsoWeek], None, None]: ...  # pragma: no cover\n\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[Union[str, IsoWeek], None, None]:\n        \"\"\"Generate range of `IsoWeek` (or `str`) from one to `n_weeks` ahead of current `value`, with given `step`.\n\n        If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeek` objects.\n\n        Arguments:\n            n_weeks: Number of weeks to be generated from current value.\n            step: Step between weeks, must be positive integer.\n            as_str: Whether to return str or IsoWeek object.\n\n        Returns:\n            Generator of `IsoWeek`s (or `str`s) from one week to `n_weeks` ahead of current `value` with given `step`.\n\n        Raises:\n            TypeError: If `n_weeks` and/or `step` is not int.\n            ValueError: If `n_weeks` and/or `step` is not strictly positive.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeek\n        iso = IsoWeek(\"2023-W01\")\n\n        tuple(iso.weeksout(4)) # ('2023-W02', '2023-W03', '2023-W04', '2023-W05')\n        tuple(iso.weeksout(6, step=2))  # ('2023-W02', '2023-W04', '2023-W06')\n        ```\n        \"\"\"\n        if not isinstance(n_weeks, int):\n            msg = f\"`n_weeks` must be an integer, found {type(n_weeks)} type\"\n            raise TypeError(msg)\n\n        if n_weeks &lt;= 0:\n            msg = f\"`n_weeks` must be strictly positive, found {n_weeks}\"\n            raise ValueError(msg)\n\n        start, end = (self + 1), (self + n_weeks)\n        return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n\n    def __contains__(self: Self, other: Any) -&gt; bool:  # noqa: ANN401\n        \"\"\"Checks if self contains `other`.\n\n        Arguments:\n            other: `IsoWeek`, `date`, `datetime` or `str`.\n\n        Returns:\n            `True` if self week contains other, `False` otherwise.\n\n        Raises:\n            TypeError: If other is not `IsoWeek`, `date`, `datetime` or `str`.\n\n        Examples:\n        ```python\n        from datetime import date\n        from iso_week_date import IsoWeek\n\n        date(2023, 1, 1) in IsoWeek(\"2023-W01\")  # False\n        date(2023, 1, 2) in IsoWeek(\"2023-W01\")  # True\n        ```\n        \"\"\"\n        if isinstance(other, (date, datetime, str, IsoWeek)):\n            _other = self._cast(other)\n            return self.__eq__(_other)\n        else:\n            msg = f\"Cannot compare type `{type(other)}` with IsoWeek\"\n            raise TypeError(msg)\n\n    @overload\n    def contains(self: Self, other: IsoWeek_T) -&gt; bool: ...  # pragma: no cover\n\n    @overload\n    def contains(self: Self, other: Iterable[IsoWeek_T]) -&gt; Tuple[bool]: ...  # pragma: no cover\n\n    @overload\n    def contains(\n        self: Self,\n        other: Union[Any, Iterable[Any]],  # noqa: ANN401\n    ) -&gt; Union[bool, Tuple[bool, ...]]: ...  # pragma: no cover\n\n    def contains(self: Self, other: Union[Any, Iterable[Any]]) -&gt; Union[bool, Tuple[bool, ...]]:\n        \"\"\"Checks if self contains `other`. `other` can be a single value or an iterable of values.\n\n        In case of an iterable, the method returns a tuple of boolean values.\n\n        Arguments:\n            other: `IsoWeek`, `date`, `datetime` or `str`, or an iterable of those types.\n\n        Returns:\n            Boolean or iterable of booleans, where each boolean indicates whether self contains the corresponding value\n                in the iterable.\n\n        Raises:\n            TypeError: If other is not IsoWeek, date, datetime or str, or an iterable of those types.\n\n        Examples:\n        ```python\n        from datetime import date\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\").contains([date(2023, 1, 1), date(2023, 1, 2)])\n        # (False, True)\n        ```\n        \"\"\"\n        if isinstance(other, (date, datetime, str, IsoWeek)):\n            return other in self\n        elif isinstance(other, Iterable):\n            return tuple(_other in self for _other in other)\n        else:\n            msg = f\"Cannot compare type `{type(other)}` with `IsoWeek`\"\n            raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.days","title":"<code>days: Tuple[date, ...]</code>  <code>property</code>","text":"<p>Returns tuple of days (as date) in the ISO week.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\").days  # (date(2023, 1, 2), ..., date(2023, 1, 8))\n</code></pre></p>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operation.</p> <p>It supports addition with the following types:</p> <ul> <li><code>int</code>: interpreted as number of weeks to be added to the <code>IsoWeek</code> value.</li> <li><code>timedelta</code>: converts <code>IsoWeek</code> to datetime (first day of week), adds <code>timedelta</code> and converts back to     <code>IsoWeek</code> object.</li> <li><code>Iterable</code> of <code>int</code> and/or <code>timedelta</code>: adds each element of the iterable to the <code>IsoWeek</code> value and returns     a generator of <code>IsoWeek</code> objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[int, timedelta, Iterable[Union[int, timedelta]]]</code> <p>Object to add to <code>IsoWeek</code>.</p> required <p>Returns:</p> Type Description <code>Union[Self, Generator[Self, None, None]]</code> <p>New <code>IsoWeek</code> or generator of <code>IsoWeek</code> object(s) with the result of the addition.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>timedelta</code> or <code>Iterable</code> of <code>int</code> and/or <code>timedelta</code>.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") + 1  # IsoWeek(\"2023-W02\")\nIsoWeek(\"2023-W01\") + timedelta(weeks=2)  # IsoWeek(\"2023-W03\")\nIsoWeek(\"2023-W01\") + timedelta(hours=1234) # IsoWeek(\"2023-W08\")\n\ntuple(IsoWeek(\"2023-W01\") + (1,2,3)) # (IsoWeek(\"2023-W02\"), IsoWeek(\"2023-W03\"), IsoWeek(\"2023-W04\"))\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __add__(\n    self: Self,\n    other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n) -&gt; Union[Self, Generator[Self, None, None]]:\n    \"\"\"Addition operation.\n\n    It supports addition with the following types:\n\n    - `int`: interpreted as number of weeks to be added to the `IsoWeek` value.\n    - `timedelta`: converts `IsoWeek` to datetime (first day of week), adds `timedelta` and converts back to\n        `IsoWeek` object.\n    - `Iterable` of `int` and/or `timedelta`: adds each element of the iterable to the `IsoWeek` value and returns\n        a generator of `IsoWeek` objects.\n\n    Arguments:\n        other: Object to add to `IsoWeek`.\n\n    Returns:\n        New `IsoWeek` or generator of `IsoWeek` object(s) with the result of the addition.\n\n    Raises:\n        TypeError: If `other` is not `int`, `timedelta` or `Iterable` of `int` and/or `timedelta`.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") + 1  # IsoWeek(\"2023-W02\")\n    IsoWeek(\"2023-W01\") + timedelta(weeks=2)  # IsoWeek(\"2023-W03\")\n    IsoWeek(\"2023-W01\") + timedelta(hours=1234) # IsoWeek(\"2023-W08\")\n\n    tuple(IsoWeek(\"2023-W01\") + (1,2,3)) # (IsoWeek(\"2023-W02\"), IsoWeek(\"2023-W03\"), IsoWeek(\"2023-W04\"))\n    ```\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() + timedelta(weeks=other))\n    elif isinstance(other, timedelta):\n        return self.from_datetime(self.to_datetime() + other)\n    elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta)) for _other in other):\n        return (self + _other for _other in other)\n    else:\n        msg = (\n            f\"Cannot add type {type(other)} to `IsoWeek`. \"\n            \"Addition is supported with `int` and `timedelta` types\",\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Checks if self contains <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p><code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self week contains other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not <code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> <p>Examples: <pre><code>from datetime import date\nfrom iso_week_date import IsoWeek\n\ndate(2023, 1, 1) in IsoWeek(\"2023-W01\")  # False\ndate(2023, 1, 2) in IsoWeek(\"2023-W01\")  # True\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __contains__(self: Self, other: Any) -&gt; bool:  # noqa: ANN401\n    \"\"\"Checks if self contains `other`.\n\n    Arguments:\n        other: `IsoWeek`, `date`, `datetime` or `str`.\n\n    Returns:\n        `True` if self week contains other, `False` otherwise.\n\n    Raises:\n        TypeError: If other is not `IsoWeek`, `date`, `datetime` or `str`.\n\n    Examples:\n    ```python\n    from datetime import date\n    from iso_week_date import IsoWeek\n\n    date(2023, 1, 1) in IsoWeek(\"2023-W01\")  # False\n    date(2023, 1, 2) in IsoWeek(\"2023-W01\")  # True\n    ```\n    \"\"\"\n    if isinstance(other, (date, datetime, str, IsoWeek)):\n        _other = self._cast(other)\n        return self.__eq__(_other)\n    else:\n        msg = f\"Cannot compare type `{type(other)}` with IsoWeek\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operation.</p> <p>It supports subtraction with the following types:</p> <ul> <li><code>int</code>: interpreted as number of weeks to be subtracted to the <code>IsoWeek</code> value.</li> <li><code>timedelta</code>: converts <code>IsoWeek</code> to datetime (first day of week), subtract <code>timedelta</code> and converts back to     <code>IsoWeek</code> object.</li> <li><code>IsoWeek</code>: will result in the difference between values in weeks (<code>int</code> type).</li> <li><code>Iterable</code> of <code>int</code>, <code>timedelta</code> and/or <code>IsoWeek</code>: subtracts each element of the iterable to the <code>IsoWeek</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]]</code> <p>Object to subtract to <code>IsoWeek</code>.</p> required <p>Returns:</p> Type Description <code>Union[int, Self, Generator[Union[int, Self], None, None]]</code> <p>Results from the subtraction, can be <code>int</code>, <code>IsoWeek</code> or Generator of <code>int</code> and/or <code>IsoWeek</code> depending on the type of <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>timedelta</code>, <code>IsoWeek</code> or <code>Iterable</code> of those types.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") - 1  # IsoWeek(\"2022-W52\")\nIsoWeek(\"2023-W01\") - timedelta(weeks=2)  # IsoWeek(\"2022-W51\")\nIsoWeek(\"2023-W01\") - timedelta(hours=1234)  # IsoWeek(\"2023-W45\")\n\ntuple(IsoWeek(\"2023-W01\") - (1,2,3))  # (IsoWeek(\"2022-W52\"), IsoWeek(\"2022-W51\"), IsoWeek(\"2022-W50\"))\n\nIsoWeek(\"2023-W01\") - IsoWeek(\"2022-W52\")  # 1\nIsoWeek(\"2023-W01\") - IsoWeek(\"2022-W51\")  # 2\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __sub__(\n    self: Self,\n    other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]:\n    \"\"\"Subtraction operation.\n\n    It supports subtraction with the following types:\n\n    - `int`: interpreted as number of weeks to be subtracted to the `IsoWeek` value.\n    - `timedelta`: converts `IsoWeek` to datetime (first day of week), subtract `timedelta` and converts back to\n        `IsoWeek` object.\n    - `IsoWeek`: will result in the difference between values in weeks (`int` type).\n    - `Iterable` of `int`, `timedelta` and/or `IsoWeek`: subtracts each element of the iterable to the `IsoWeek`.\n\n    Arguments:\n        other: Object to subtract to `IsoWeek`.\n\n    Returns:\n        Results from the subtraction, can be `int`, `IsoWeek` or Generator of `int` and/or `IsoWeek` depending\n            on the type of `other`.\n\n    Raises:\n        TypeError: If `other` is not `int`, `timedelta`, `IsoWeek` or `Iterable` of those types.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") - 1  # IsoWeek(\"2022-W52\")\n    IsoWeek(\"2023-W01\") - timedelta(weeks=2)  # IsoWeek(\"2022-W51\")\n    IsoWeek(\"2023-W01\") - timedelta(hours=1234)  # IsoWeek(\"2023-W45\")\n\n    tuple(IsoWeek(\"2023-W01\") - (1,2,3))  # (IsoWeek(\"2022-W52\"), IsoWeek(\"2022-W51\"), IsoWeek(\"2022-W50\"))\n\n    IsoWeek(\"2023-W01\") - IsoWeek(\"2022-W52\")  # 1\n    IsoWeek(\"2023-W01\") - IsoWeek(\"2022-W51\")  # 2\n    ```\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() - timedelta(weeks=other))\n    if isinstance(other, timedelta):\n        return self.from_datetime(self.to_datetime() - other)\n    elif isinstance(other, IsoWeek) and self.offset_ == other.offset_:\n        return (self.to_date() - other.to_date()).days // 7\n    elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta, IsoWeek)) for _other in other):\n        return (self - _other for _other in other)\n    else:\n        msg = (\n            f\"Cannot subtract type {type(other)} to `IsoWeek`. \"\n            \"Subtraction is supported with `int`, `timedelta` and `IsoWeek` types\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.contains","title":"<code>contains(other)</code>","text":"<p>Checks if self contains <code>other</code>. <code>other</code> can be a single value or an iterable of values.</p> <p>In case of an iterable, the method returns a tuple of boolean values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Any, Iterable[Any]]</code> <p><code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>, or an iterable of those types.</p> required <p>Returns:</p> Type Description <code>Union[bool, Tuple[bool, ...]]</code> <p>Boolean or iterable of booleans, where each boolean indicates whether self contains the corresponding value in the iterable.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not IsoWeek, date, datetime or str, or an iterable of those types.</p> <p>Examples: <pre><code>from datetime import date\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\").contains([date(2023, 1, 1), date(2023, 1, 2)])\n# (False, True)\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def contains(self: Self, other: Union[Any, Iterable[Any]]) -&gt; Union[bool, Tuple[bool, ...]]:\n    \"\"\"Checks if self contains `other`. `other` can be a single value or an iterable of values.\n\n    In case of an iterable, the method returns a tuple of boolean values.\n\n    Arguments:\n        other: `IsoWeek`, `date`, `datetime` or `str`, or an iterable of those types.\n\n    Returns:\n        Boolean or iterable of booleans, where each boolean indicates whether self contains the corresponding value\n            in the iterable.\n\n    Raises:\n        TypeError: If other is not IsoWeek, date, datetime or str, or an iterable of those types.\n\n    Examples:\n    ```python\n    from datetime import date\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\").contains([date(2023, 1, 1), date(2023, 1, 2)])\n    # (False, True)\n    ```\n    \"\"\"\n    if isinstance(other, (date, datetime, str, IsoWeek)):\n        return other in self\n    elif isinstance(other, Iterable):\n        return tuple(_other in self for _other in other)\n    else:\n        msg = f\"Cannot compare type `{type(other)}` with `IsoWeek`\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.nth","title":"<code>nth(n)</code>","text":"<p>Returns Nth day of the week using the ISO weekday numbering convention (1=First, 2=Second, ..., 7=Last day).</p> <p>Info</p> <p>Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Day number between 1 and 7.</p> required <p>Returns:</p> Type Description <code>date</code> <p><code>date</code> object representing the Nth day of the week.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>n</code> is not an integer.</p> <code>ValueError</code> <p>If <code>n</code> is not between 1 and 7.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\").nth(1)  # date(2023, 1, 2)\nIsoWeek(\"2023-W01\").nth(7)  # date(2023, 1, 8)\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def nth(self: Self, n: int) -&gt; date:\n    \"\"\"Returns Nth day of the week using the ISO weekday numbering convention (1=First, 2=Second, ..., 7=Last day).\n\n    !!! info\n        Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n    Arguments:\n        n: Day number between 1 and 7.\n\n    Returns:\n        `date` object representing the Nth day of the week.\n\n    Raises:\n        TypeError: If `n` is not an integer.\n        ValueError: If `n` is not between 1 and 7.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\").nth(1)  # date(2023, 1, 2)\n    IsoWeek(\"2023-W01\").nth(7)  # date(2023, 1, 8)\n    ```\n    \"\"\"\n    if not isinstance(n, int):\n        msg = f\"`n` must be an integer, found {type(n)}\"\n        raise TypeError(msg)\n    if n not in range(1, 8):\n        msg = f\"`n` must be between 1 and 7, found {n}\"\n        raise ValueError(msg)\n\n    return self.days[n - 1]\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_date","title":"<code>to_date(weekday=1)</code>","text":"<p>Converts <code>IsoWeek</code> to <code>date</code> object with the given <code>weekday</code>.</p> <p>If no weekday is provided then the first day of the week is used.</p> <p>Info</p> <p>Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.</p> <p>Parameters:</p> Name Type Description Default <code>weekday</code> <code>int</code> <p>Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7 is the last day of the week.</p> <code>1</code> <p>Returns:</p> Type Description <code>date</code> <p><code>IsoWeek</code> value in <code>date</code> type with the given weekday.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>weekday</code> is not an integer.</p> <code>ValueError</code> <p>If <code>weekday</code> is not between 1 and 7.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\").to_date()  # datetime.date(2023, 1, 2)\nIsoWeek(\"2023-W01\").to_date(3)  # datetime.date(2023, 1, 4)\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_date(self: Self, weekday: int = 1) -&gt; date:\n    \"\"\"Converts `IsoWeek` to `date` object with the given `weekday`.\n\n    If no weekday is provided then the first day of the week is used.\n\n    !!! info\n        Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n    Arguments:\n        weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n            is the last day of the week.\n\n    Returns:\n        `IsoWeek` value in `date` type with the given weekday.\n\n    Raises:\n        TypeError: If `weekday` is not an integer.\n        ValueError: If `weekday` is not between 1 and 7.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\").to_date()  # datetime.date(2023, 1, 2)\n    IsoWeek(\"2023-W01\").to_date(3)  # datetime.date(2023, 1, 4)\n    ```\n    \"\"\"\n    return self.to_datetime(weekday).date()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_datetime","title":"<code>to_datetime(weekday=1)</code>","text":"<p>Converts <code>IsoWeek</code> to <code>datetime</code> object with the given weekday.</p> <p>If no weekday is provided then the first day of the week is used.</p> <p>Info</p> <p>Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.</p> <p>Parameters:</p> Name Type Description Default <code>weekday</code> <code>int</code> <p>Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7 is the last day of the week.</p> <code>1</code> <p>Returns:</p> Type Description <code>datetime</code> <p><code>IsoWeek</code> value in <code>datetime</code> type with the given weekday.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>weekday</code> is not an integer.</p> <code>ValueError</code> <p>If <code>weekday</code> is not between 1 and 7.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\").to_datetime()  # datetime.datetime(2023, 1, 2, 0, 0)\nIsoWeek(\"2023-W01\").to_datetime(3)  # datetime.datetime(2023, 1, 4, 0, 0)\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_datetime(self: Self, weekday: int = 1) -&gt; datetime:\n    \"\"\"Converts `IsoWeek` to `datetime` object with the given weekday.\n\n    If no weekday is provided then the first day of the week is used.\n\n    !!! info\n        Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n    Arguments:\n        weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n            is the last day of the week.\n\n    Returns:\n        `IsoWeek` value in `datetime` type with the given weekday.\n\n    Raises:\n        TypeError: If `weekday` is not an integer.\n        ValueError: If `weekday` is not between 1 and 7.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\").to_datetime()  # datetime.datetime(2023, 1, 2, 0, 0)\n    IsoWeek(\"2023-W01\").to_datetime(3)  # datetime.datetime(2023, 1, 4, 0, 0)\n    ```\n    \"\"\"\n    if not isinstance(weekday, int):\n        msg = f\"`weekday` must be an integer between 1 and 7, found {type(weekday)}\"\n        raise TypeError(msg)\n    if weekday not in range(1, 8):\n        msg = f\"Invalid `weekday`. Weekday must be between 1 and 7, found {weekday}\"\n        raise ValueError(msg)\n\n    return super()._to_datetime(f\"{self.value_}-{weekday}\")\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.weeksout","title":"<code>weeksout(n_weeks, *, step=1, as_str=True)</code>","text":"<p>Generate range of <code>IsoWeek</code> (or <code>str</code>) from one to <code>n_weeks</code> ahead of current <code>value</code>, with given <code>step</code>.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return <code>str</code> values, otherwise it will return <code>IsoWeek</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>n_weeks</code> <code>int</code> <p>Number of weeks to be generated from current value.</p> required <code>step</code> <code>int</code> <p>Step between weeks, must be positive integer.</p> <code>1</code> <code>as_str</code> <code>bool</code> <p>Whether to return str or IsoWeek object.</p> <code>True</code> <p>Returns:</p> Type Description <code>Generator[Union[str, IsoWeek], None, None]</code> <p>Generator of <code>IsoWeek</code>s (or <code>str</code>s) from one week to <code>n_weeks</code> ahead of current <code>value</code> with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>n_weeks</code> and/or <code>step</code> is not int.</p> <code>ValueError</code> <p>If <code>n_weeks</code> and/or <code>step</code> is not strictly positive.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeek\niso = IsoWeek(\"2023-W01\")\n\ntuple(iso.weeksout(4)) # ('2023-W02', '2023-W03', '2023-W04', '2023-W05')\ntuple(iso.weeksout(6, step=2))  # ('2023-W02', '2023-W04', '2023-W06')\n</code></pre></p> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def weeksout(\n    self: Self,\n    n_weeks: int,\n    *,\n    step: int = 1,\n    as_str: bool = True,\n) -&gt; Generator[Union[str, IsoWeek], None, None]:\n    \"\"\"Generate range of `IsoWeek` (or `str`) from one to `n_weeks` ahead of current `value`, with given `step`.\n\n    If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeek` objects.\n\n    Arguments:\n        n_weeks: Number of weeks to be generated from current value.\n        step: Step between weeks, must be positive integer.\n        as_str: Whether to return str or IsoWeek object.\n\n    Returns:\n        Generator of `IsoWeek`s (or `str`s) from one week to `n_weeks` ahead of current `value` with given `step`.\n\n    Raises:\n        TypeError: If `n_weeks` and/or `step` is not int.\n        ValueError: If `n_weeks` and/or `step` is not strictly positive.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeek\n    iso = IsoWeek(\"2023-W01\")\n\n    tuple(iso.weeksout(4)) # ('2023-W02', '2023-W03', '2023-W04', '2023-W05')\n    tuple(iso.weeksout(6, step=2))  # ('2023-W02', '2023-W04', '2023-W06')\n    ```\n    \"\"\"\n    if not isinstance(n_weeks, int):\n        msg = f\"`n_weeks` must be an integer, found {type(n_weeks)} type\"\n        raise TypeError(msg)\n\n    if n_weeks &lt;= 0:\n        msg = f\"`n_weeks` must be strictly positive, found {n_weeks}\"\n        raise ValueError(msg)\n\n    start, end = (self + 1), (self + n_weeks)\n    return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n</code></pre>"},{"location":"api/isoweekdate/","title":"<code>IsoWeekDate</code> class","text":""},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate","title":"<code>iso_week_date.isoweekdate.IsoWeekDate</code>","text":"<p>             Bases: <code>BaseIsoWeek</code></p> <p>Represents ISO Week date in the  \"YYYY-WNN-D\" format.</p> <p>The class implements methods and functionalities to work directly with iso week date format and avoid moving back and forth between <code>date</code>, <code>datetime</code> and <code>str</code> objects.</p> <p>Attributes:</p> Name Type Description <code>value_</code> <p>iso-week string of format \"YYYY-WNN-D\" where:</p> <ul> <li>YYYY is between 0001 and 9999</li> <li>W is a literal character</li> <li>NN is between 01 and 53</li> <li>D is between 1 and 7</li> </ul> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>class IsoWeekDate(BaseIsoWeek):\n    \"\"\"Represents [ISO Week date](https://en.wikipedia.org/wiki/ISO_week_date) in the  _\"YYYY-WNN-D\"_ format.\n\n    The class implements methods and functionalities to work directly with iso week date format and avoid moving back\n    and forth between `date`, `datetime` and `str` objects.\n\n    Attributes:\n        value_: iso-week string of format \"YYYY-WNN-D\" where:\n\n            - YYYY is between 0001 and 9999\n            - W is a literal character\n            - NN is between 01 and 53\n            - D is between 1 and 7\n    \"\"\"\n\n    _pattern = ISOWEEKDATE_PATTERN\n\n    _format = ISOWEEKDATE__FORMAT\n    _date_format = ISOWEEKDATE__DATE_FORMAT\n\n    @property\n    def day(self: Self) -&gt; int:\n        \"\"\"Returns day number as integer.\n\n        Returns:\n            `int` with day number as integer corresponding to the `IsoWeekDate`.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeekDate\n\n        IsoWeekDate(\"2023-W01-1\").day  # 1\n        ```\n        \"\"\"\n        return int(self.value_[9])\n\n    @property\n    def isoweek(self: Self) -&gt; str:\n        \"\"\"Returns iso-week string value.\n\n        Returns:\n            `str` with iso-week string value (YYYY-WNN format) corresponding to the `IsoWeekDate`.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeekDate\n\n        IsoWeekDate(\"2023-W01-1\").isoweek  # \"2023-W01\"\n        ```\n        \"\"\"\n        return self.value_[:8]\n\n    def to_datetime(self: Self) -&gt; datetime:\n        \"\"\"Converts `IsoWeekDate` to `datetime` object.\n\n        Returns:\n            `datetime` corresponding to the `IsoWeekDate`.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeekDate\n\n        IsoWeekDate(\"2023-W01-1\").to_datetime()  # datetime.datetime(2023, 1, 2, 0, 0)\n        IsoWeekDate(\"2023-W01-3\").to_datetime()  # datetime.datetime(2023, 1, 4, 0, 0)\n        ```\n        \"\"\"\n        return super()._to_datetime(self.value_)\n\n    def to_date(self: Self) -&gt; date:\n        \"\"\"Converts `IsoWeekDate` to `date` object.\n\n        Returns:\n            `date` corresponding to the `IsoWeekDate`.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeekDate\n\n        IsoWeekDate(\"2023-W01-1\").to_date()  # datetime.date(2023, 1, 2)\n        IsoWeekDate(\"2023-W01-3\").to_date()  # datetime.date(2023, 1, 4)\n        ```\n        \"\"\"\n        return self.to_datetime().date()\n\n    @overload\n    def __add__(self: Self, other: Union[int, timedelta]) -&gt; Self: ...  # pragma: no cover\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Iterable[Union[int, timedelta]],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n    ) -&gt; Union[Self, Generator[Self, None, None]]: ...  # pragma: no cover\n\n    def __add__(\n        self: Self,\n        other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n    ) -&gt; Union[Self, Generator[Self, None, None]]:\n        \"\"\"Addition operation.\n\n        It supports addition with the following types:\n\n        - `int`: interpreted as number of days to be added to the `IsoWeekDate` value.\n        - `timedelta`: converts `IsoWeekDate` to `datetime`, adds `timedelta` and converts back to `IsoWeekDate` object.\n        - `Iterable` of `int` and/or `timedelta`: adds each element of the iterable to the `IsoWeekDate` value and\n            returns a generator of `IsoWeekDate` objects.\n\n        Arguments:\n            other: Object to add to `IsoWeekDate`.\n\n        Returns:\n            New `IsoWeekDate` or generator of `IsoWeekDate` object(s) with the result of the addition.\n\n        Raises:\n            TypeError: If `other` is not `int`, `timedelta` or `Iterable` of `int` and/or `timedelta`.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeekDate\n\n        IsoWeekDate(\"2023-W01-1\") + 1  # IsoWeekDate(\"2023-W01-2\")\n        IsoWeekDate(\"2023-W01-1\") + timedelta(weeks=2)  # IsoWeekDate(\"2023-W03-1\")\n\n        tuple(IsoWeekDate(\"2023-W01-1\") + (1,2)) # (IsoWeekDate(\"2023-W01-2\"), IsoWeekDate(\"2023-W01-3\"))\n        ```\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() + timedelta(days=other))\n        elif isinstance(other, timedelta):\n            return self.from_datetime(self.to_datetime() + other)\n        elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta)) for _other in other):\n            return (self + _other for _other in other)\n        else:\n            msg = (\n                f\"Cannot add type {type(other)} to `IsoWeekDate`. \"\n                \"Addition is supported with `int` and `timedelta` types\",\n            )\n            raise TypeError(msg)\n\n    @overload\n    def __sub__(self: Self, other: Union[int, timedelta]) -&gt; Self: ...  # pragma: no cover\n\n    @overload\n    def __sub__(self: Self, other: Self) -&gt; int: ...  # pragma: no cover\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Iterable[Union[int, timedelta]],\n    ) -&gt; Generator[Self, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __sub__(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...  # pragma: no cover\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n    ) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]: ...  # pragma: no cover\n\n    def __sub__(\n        self: Self,\n        other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n    ) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]:\n        \"\"\"Subtraction operation.\n\n        It supports subtraction with the following types:\n\n        - `int`: interpreted as number of days to be subtracted to the `IsoWeekDate` value.\n        - `timedelta`: converts `IsoWeekDate` to `datetime`, subtracts `timedelta` and converts back to `IsoWeekDate`\n            object.\n        - `IsoWeekDate`: will result in the difference between values in days (`int` type).\n        - `Iterable` of `int`, `timedelta` and/or `IsoWeekDate`: subtracts each element of the iterable to the\n            `IsoWeekDate`.\n\n        Arguments:\n            other: Object to subtract to `IsoWeekDate`.\n\n        Returns:\n            Results from the subtraction, can be `int`, `IsoWeekDate` or Generator of `int` and/or `IsoWeekDate`\n                depending on the type of `other`.\n\n\n        Raises:\n            TypeError: If `other` is not `int`, `timedelta`, `IsoWeekDate` or `Iterable` of those types.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeekDate\n\n        IsoWeekDate(\"2023-W01-1\") - 1  # IsoWeekDate(\"2022-W52-7\")\n        IsoWeekDate(\"2023-W01-1\") - timedelta(weeks=2)  # IsoWeekDate(\"2022-W51-1\")\n\n        tuple(IsoWeekDate(\"2023-W01-1\") - (1,2))  # (IsoWeekDate(\"2022-W52-7\"), IsoWeekDate(\"2022-W52-6\"))\n\n        IsoWeekDate(\"2023-W01-1\") - IsoWeekDate(\"2022-W52-3\")  # 5\n\n        ```\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() - timedelta(days=other))\n        if isinstance(other, timedelta):\n            return self.from_datetime(self.to_datetime() - other)\n        elif isinstance(other, IsoWeekDate) and self.offset_ == other.offset_:\n            return (self.to_date() - other.to_date()).days\n        elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta, IsoWeekDate)) for _other in other):\n            return (self - _other for _other in other)\n        else:\n            msg = (\n                f\"Cannot subtract type {type(other)} to `IsoWeekDate`. \"\n                \"Subtraction is supported with `int`, `timedelta` and `IsoWeekDate` types\",\n            )\n            raise TypeError(msg)\n\n    @overload\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: Literal[True],\n    ) -&gt; Generator[str, None, None]: ...  # pragma: no cover\n\n    @overload\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: Literal[False],\n    ) -&gt; Generator[IsoWeekDate, None, None]: ...  # pragma: no cover\n\n    @overload\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[Union[str, IsoWeekDate], None, None]: ...  # pragma: no cover\n\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[Union[str, IsoWeekDate], None, None]:\n        \"\"\"Generate range of `IsoWeekDate` (or `str`) from one to `n_days` ahead of current `value`, with given `step`.\n\n        If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeekDate` objects.\n\n        Arguments:\n            n_days: Number of days to be generated from current value.\n            step: Step between days, must be positive integer.\n            as_str: Whether to return `str` or `IsoWeekDate` object.\n\n        Returns:\n            Generator of `IsoWeekDate`s (or `str`s) from one day to `n_days` ahead of current `value` with given `step`.\n\n        Raises:\n            TypeError: If `n_days` and/or `step` is not int.\n            ValueError: If `n_days` and/or `step` is not strictly positive.\n\n        Examples:\n        ```py\n        from iso_week_date import IsoWeekDate\n        iso = IsoWeekDate(\"2023-W01-1\")\n\n        tuple(iso.daysout(3)) # ('2023-W01-2', '2023-W01-3', '2023-W01-4')\n        tuple(iso.daysout(6, step=2)) # ('2023-W01-2', '2023-W01-4', '2023-W01-6')\n        ```\n        \"\"\"\n        if not isinstance(n_days, int):\n            msg = f\"`n_weeks` must be integer, found {type(n_days)} type\"\n            raise TypeError(msg)\n\n        if n_days &lt;= 0:\n            msg = f\"`n_weeks` must be strictly positive, found {n_days}\"\n            raise ValueError(msg)\n\n        start, end = (self + 1), (self + n_days)\n        return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.day","title":"<code>day: int</code>  <code>property</code>","text":"<p>Returns day number as integer.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>int</code> with day number as integer corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeekDate\n\nIsoWeekDate(\"2023-W01-1\").day  # 1\n</code></pre></p>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.isoweek","title":"<code>isoweek: str</code>  <code>property</code>","text":"<p>Returns iso-week string value.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>str</code> with iso-week string value (YYYY-WNN format) corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeekDate\n\nIsoWeekDate(\"2023-W01-1\").isoweek  # \"2023-W01\"\n</code></pre></p>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operation.</p> <p>It supports addition with the following types:</p> <ul> <li><code>int</code>: interpreted as number of days to be added to the <code>IsoWeekDate</code> value.</li> <li><code>timedelta</code>: converts <code>IsoWeekDate</code> to <code>datetime</code>, adds <code>timedelta</code> and converts back to <code>IsoWeekDate</code> object.</li> <li><code>Iterable</code> of <code>int</code> and/or <code>timedelta</code>: adds each element of the iterable to the <code>IsoWeekDate</code> value and     returns a generator of <code>IsoWeekDate</code> objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[int, timedelta, Iterable[Union[int, timedelta]]]</code> <p>Object to add to <code>IsoWeekDate</code>.</p> required <p>Returns:</p> Type Description <code>Union[Self, Generator[Self, None, None]]</code> <p>New <code>IsoWeekDate</code> or generator of <code>IsoWeekDate</code> object(s) with the result of the addition.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>timedelta</code> or <code>Iterable</code> of <code>int</code> and/or <code>timedelta</code>.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeekDate\n\nIsoWeekDate(\"2023-W01-1\") + 1  # IsoWeekDate(\"2023-W01-2\")\nIsoWeekDate(\"2023-W01-1\") + timedelta(weeks=2)  # IsoWeekDate(\"2023-W03-1\")\n\ntuple(IsoWeekDate(\"2023-W01-1\") + (1,2)) # (IsoWeekDate(\"2023-W01-2\"), IsoWeekDate(\"2023-W01-3\"))\n</code></pre></p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __add__(\n    self: Self,\n    other: Union[int, timedelta, Iterable[Union[int, timedelta]]],\n) -&gt; Union[Self, Generator[Self, None, None]]:\n    \"\"\"Addition operation.\n\n    It supports addition with the following types:\n\n    - `int`: interpreted as number of days to be added to the `IsoWeekDate` value.\n    - `timedelta`: converts `IsoWeekDate` to `datetime`, adds `timedelta` and converts back to `IsoWeekDate` object.\n    - `Iterable` of `int` and/or `timedelta`: adds each element of the iterable to the `IsoWeekDate` value and\n        returns a generator of `IsoWeekDate` objects.\n\n    Arguments:\n        other: Object to add to `IsoWeekDate`.\n\n    Returns:\n        New `IsoWeekDate` or generator of `IsoWeekDate` object(s) with the result of the addition.\n\n    Raises:\n        TypeError: If `other` is not `int`, `timedelta` or `Iterable` of `int` and/or `timedelta`.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeekDate\n\n    IsoWeekDate(\"2023-W01-1\") + 1  # IsoWeekDate(\"2023-W01-2\")\n    IsoWeekDate(\"2023-W01-1\") + timedelta(weeks=2)  # IsoWeekDate(\"2023-W03-1\")\n\n    tuple(IsoWeekDate(\"2023-W01-1\") + (1,2)) # (IsoWeekDate(\"2023-W01-2\"), IsoWeekDate(\"2023-W01-3\"))\n    ```\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() + timedelta(days=other))\n    elif isinstance(other, timedelta):\n        return self.from_datetime(self.to_datetime() + other)\n    elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta)) for _other in other):\n        return (self + _other for _other in other)\n    else:\n        msg = (\n            f\"Cannot add type {type(other)} to `IsoWeekDate`. \"\n            \"Addition is supported with `int` and `timedelta` types\",\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operation.</p> <p>It supports subtraction with the following types:</p> <ul> <li><code>int</code>: interpreted as number of days to be subtracted to the <code>IsoWeekDate</code> value.</li> <li><code>timedelta</code>: converts <code>IsoWeekDate</code> to <code>datetime</code>, subtracts <code>timedelta</code> and converts back to <code>IsoWeekDate</code>     object.</li> <li><code>IsoWeekDate</code>: will result in the difference between values in days (<code>int</code> type).</li> <li><code>Iterable</code> of <code>int</code>, <code>timedelta</code> and/or <code>IsoWeekDate</code>: subtracts each element of the iterable to the     <code>IsoWeekDate</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]]</code> <p>Object to subtract to <code>IsoWeekDate</code>.</p> required <p>Returns:</p> Type Description <code>Union[int, Self, Generator[Union[int, Self], None, None]]</code> <p>Results from the subtraction, can be <code>int</code>, <code>IsoWeekDate</code> or Generator of <code>int</code> and/or <code>IsoWeekDate</code> depending on the type of <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>timedelta</code>, <code>IsoWeekDate</code> or <code>Iterable</code> of those types.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeekDate\n\nIsoWeekDate(\"2023-W01-1\") - 1  # IsoWeekDate(\"2022-W52-7\")\nIsoWeekDate(\"2023-W01-1\") - timedelta(weeks=2)  # IsoWeekDate(\"2022-W51-1\")\n\ntuple(IsoWeekDate(\"2023-W01-1\") - (1,2))  # (IsoWeekDate(\"2022-W52-7\"), IsoWeekDate(\"2022-W52-6\"))\n\nIsoWeekDate(\"2023-W01-1\") - IsoWeekDate(\"2022-W52-3\")  # 5\n</code></pre></p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __sub__(\n    self: Self,\n    other: Union[int, timedelta, Self, Iterable[Union[int, timedelta, Self]]],\n) -&gt; Union[int, Self, Generator[Union[int, Self], None, None]]:\n    \"\"\"Subtraction operation.\n\n    It supports subtraction with the following types:\n\n    - `int`: interpreted as number of days to be subtracted to the `IsoWeekDate` value.\n    - `timedelta`: converts `IsoWeekDate` to `datetime`, subtracts `timedelta` and converts back to `IsoWeekDate`\n        object.\n    - `IsoWeekDate`: will result in the difference between values in days (`int` type).\n    - `Iterable` of `int`, `timedelta` and/or `IsoWeekDate`: subtracts each element of the iterable to the\n        `IsoWeekDate`.\n\n    Arguments:\n        other: Object to subtract to `IsoWeekDate`.\n\n    Returns:\n        Results from the subtraction, can be `int`, `IsoWeekDate` or Generator of `int` and/or `IsoWeekDate`\n            depending on the type of `other`.\n\n\n    Raises:\n        TypeError: If `other` is not `int`, `timedelta`, `IsoWeekDate` or `Iterable` of those types.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeekDate\n\n    IsoWeekDate(\"2023-W01-1\") - 1  # IsoWeekDate(\"2022-W52-7\")\n    IsoWeekDate(\"2023-W01-1\") - timedelta(weeks=2)  # IsoWeekDate(\"2022-W51-1\")\n\n    tuple(IsoWeekDate(\"2023-W01-1\") - (1,2))  # (IsoWeekDate(\"2022-W52-7\"), IsoWeekDate(\"2022-W52-6\"))\n\n    IsoWeekDate(\"2023-W01-1\") - IsoWeekDate(\"2022-W52-3\")  # 5\n\n    ```\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() - timedelta(days=other))\n    if isinstance(other, timedelta):\n        return self.from_datetime(self.to_datetime() - other)\n    elif isinstance(other, IsoWeekDate) and self.offset_ == other.offset_:\n        return (self.to_date() - other.to_date()).days\n    elif isinstance(other, Iterable) and all(isinstance(_other, (int, timedelta, IsoWeekDate)) for _other in other):\n        return (self - _other for _other in other)\n    else:\n        msg = (\n            f\"Cannot subtract type {type(other)} to `IsoWeekDate`. \"\n            \"Subtraction is supported with `int`, `timedelta` and `IsoWeekDate` types\",\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.daysout","title":"<code>daysout(n_days, *, step=1, as_str=True)</code>","text":"<p>Generate range of <code>IsoWeekDate</code> (or <code>str</code>) from one to <code>n_days</code> ahead of current <code>value</code>, with given <code>step</code>.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return <code>str</code> values, otherwise it will return <code>IsoWeekDate</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>n_days</code> <code>int</code> <p>Number of days to be generated from current value.</p> required <code>step</code> <code>int</code> <p>Step between days, must be positive integer.</p> <code>1</code> <code>as_str</code> <code>bool</code> <p>Whether to return <code>str</code> or <code>IsoWeekDate</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>Generator[Union[str, IsoWeekDate], None, None]</code> <p>Generator of <code>IsoWeekDate</code>s (or <code>str</code>s) from one day to <code>n_days</code> ahead of current <code>value</code> with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>n_days</code> and/or <code>step</code> is not int.</p> <code>ValueError</code> <p>If <code>n_days</code> and/or <code>step</code> is not strictly positive.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeekDate\niso = IsoWeekDate(\"2023-W01-1\")\n\ntuple(iso.daysout(3)) # ('2023-W01-2', '2023-W01-3', '2023-W01-4')\ntuple(iso.daysout(6, step=2)) # ('2023-W01-2', '2023-W01-4', '2023-W01-6')\n</code></pre></p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def daysout(\n    self: Self,\n    n_days: int,\n    *,\n    step: int = 1,\n    as_str: bool = True,\n) -&gt; Generator[Union[str, IsoWeekDate], None, None]:\n    \"\"\"Generate range of `IsoWeekDate` (or `str`) from one to `n_days` ahead of current `value`, with given `step`.\n\n    If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeekDate` objects.\n\n    Arguments:\n        n_days: Number of days to be generated from current value.\n        step: Step between days, must be positive integer.\n        as_str: Whether to return `str` or `IsoWeekDate` object.\n\n    Returns:\n        Generator of `IsoWeekDate`s (or `str`s) from one day to `n_days` ahead of current `value` with given `step`.\n\n    Raises:\n        TypeError: If `n_days` and/or `step` is not int.\n        ValueError: If `n_days` and/or `step` is not strictly positive.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeekDate\n    iso = IsoWeekDate(\"2023-W01-1\")\n\n    tuple(iso.daysout(3)) # ('2023-W01-2', '2023-W01-3', '2023-W01-4')\n    tuple(iso.daysout(6, step=2)) # ('2023-W01-2', '2023-W01-4', '2023-W01-6')\n    ```\n    \"\"\"\n    if not isinstance(n_days, int):\n        msg = f\"`n_weeks` must be integer, found {type(n_days)} type\"\n        raise TypeError(msg)\n\n    if n_days &lt;= 0:\n        msg = f\"`n_weeks` must be strictly positive, found {n_days}\"\n        raise ValueError(msg)\n\n    start, end = (self + 1), (self + n_days)\n    return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_date","title":"<code>to_date()</code>","text":"<p>Converts <code>IsoWeekDate</code> to <code>date</code> object.</p> <p>Returns:</p> Type Description <code>date</code> <p><code>date</code> corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeekDate\n\nIsoWeekDate(\"2023-W01-1\").to_date()  # datetime.date(2023, 1, 2)\nIsoWeekDate(\"2023-W01-3\").to_date()  # datetime.date(2023, 1, 4)\n</code></pre></p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_date(self: Self) -&gt; date:\n    \"\"\"Converts `IsoWeekDate` to `date` object.\n\n    Returns:\n        `date` corresponding to the `IsoWeekDate`.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeekDate\n\n    IsoWeekDate(\"2023-W01-1\").to_date()  # datetime.date(2023, 1, 2)\n    IsoWeekDate(\"2023-W01-3\").to_date()  # datetime.date(2023, 1, 4)\n    ```\n    \"\"\"\n    return self.to_datetime().date()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_datetime","title":"<code>to_datetime()</code>","text":"<p>Converts <code>IsoWeekDate</code> to <code>datetime</code> object.</p> <p>Returns:</p> Type Description <code>datetime</code> <p><code>datetime</code> corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples: <pre><code>from iso_week_date import IsoWeekDate\n\nIsoWeekDate(\"2023-W01-1\").to_datetime()  # datetime.datetime(2023, 1, 2, 0, 0)\nIsoWeekDate(\"2023-W01-3\").to_datetime()  # datetime.datetime(2023, 1, 4, 0, 0)\n</code></pre></p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_datetime(self: Self) -&gt; datetime:\n    \"\"\"Converts `IsoWeekDate` to `datetime` object.\n\n    Returns:\n        `datetime` corresponding to the `IsoWeekDate`.\n\n    Examples:\n    ```py\n    from iso_week_date import IsoWeekDate\n\n    IsoWeekDate(\"2023-W01-1\").to_datetime()  # datetime.datetime(2023, 1, 2, 0, 0)\n    IsoWeekDate(\"2023-W01-3\").to_datetime()  # datetime.datetime(2023, 1, 4, 0, 0)\n    ```\n    \"\"\"\n    return super()._to_datetime(self.value_)\n</code></pre>"},{"location":"api/mixins/","title":"Mixin's","text":"<p>Mixin's are used to add functionality to the base class.</p> <p>In particular:</p> <ul> <li><code>ParserMixin</code>: implements the parsing methods from different types (<code>from_*</code> methods)</li> <li><code>ConverterMixin</code>: implements the conversion methods to different types (<code>to_*</code> methods)</li> <li><code>ComparatorMixin</code>: implements the comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</li> </ul>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin","title":"<code>iso_week_date.mixin.ParserMixin</code>","text":"<p>             Bases: <code>IsoWeekProtocol</code></p> <p>Mixin that handles conversion from types.</p> <p><code>ParserMixin</code> implements <code>from_*</code> (class) methods to parse from:</p> <ul> <li><code>str</code>: string matching <code>pattern</code>, will be validated.</li> <li><code>str</code>: string matching <code>compact_pattern</code>, will be validated.</li> <li><code>date</code>: casted to ISO Week <code>_date_format</code> using <code>.strftime()</code> method after applying <code>offset_</code>.</li> <li><code>datetime</code>:casted to ISO Week <code>_date_format</code> using <code>.strftime()</code> method after applying <code>offset_</code>.</li> </ul> <p>Additionally, it implements <code>._cast()</code> class method that automatically casts to ISOWeek-like type from the by calling the appropriate method for parsing.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>class ParserMixin(IsoWeekProtocol):\n    \"\"\"Mixin that handles conversion from types.\n\n    `ParserMixin` implements `from_*` (class) methods to parse from:\n\n    - `str`: string matching `pattern`, will be validated.\n    - `str`: string matching `compact_pattern`, will be validated.\n    - `date`: casted to ISO Week `_date_format` using `.strftime()` method after applying `offset_`.\n    - `datetime`:casted to ISO Week `_date_format` using `.strftime()` method after applying `offset_`.\n\n    Additionally, it implements `._cast()` class method that automatically casts to ISOWeek-like type from the by\n    calling the appropriate method for parsing.\n    \"\"\"\n\n    @classmethod\n    def from_string(cls: Type[Self], _str: str) -&gt; Self:\n        \"\"\"Parse a string object in `_pattern` format.\"\"\"\n        if not isinstance(_str, str):\n            msg = f\"Expected `str` type, found {type(_str)}\"\n            raise TypeError(msg)\n        return cls(_str)\n\n    @classmethod\n    def from_compact(cls: Type[Self], _str: str) -&gt; Self:\n        \"\"\"Parse a string object in `_compact_format` format.\n\n        Since values are validated in the initialization method, our goal in this method is to \"add\" the dashes in the\n        appropriate places. To achieve this we:\n\n        - First check that the length of the string is correct (either 7 or 8).\n        - Split the string in 3 parts.\n        - Remove (filter) empty values.\n        - Finally join them with a dash in between.\n        \"\"\"\n        if not isinstance(_str, str):\n            msg = f\"Expected `str` type, found {type(_str)}\"\n            raise TypeError(msg)\n\n        if len(_str) != len(cls._compact_format):\n            raise ValueError(format_err_msg(cls._compact_format, _str))\n\n        split_idx = (0, 4, 7, None)\n        value = \"-\".join(filter(None, (_str[i:j] for i, j in zip(split_idx[:-1], split_idx[1:]))))\n        return cls(value)\n\n    @classmethod\n    def from_date(cls: Type[Self], _date: date) -&gt; Self:\n        \"\"\"Parse a date object to `_date_format` after adjusting by `offset_`.\"\"\"\n        if not isinstance(_date, date):\n            msg = f\"Expected `date` type, found {type(_date)}\"\n            raise TypeError(msg)\n        return cls((_date - cls.offset_).strftime(cls._date_format))\n\n    @classmethod\n    def from_datetime(cls: Type[Self], _datetime: datetime) -&gt; Self:\n        \"\"\"Parse a datetime object to `_date_format` after adjusting by `offset_`.\"\"\"\n        if not isinstance(_datetime, datetime):\n            msg = f\"Expected `datetime` type, found {type(_datetime)}\"\n            raise TypeError(msg)\n\n        return cls((_datetime - cls.offset_).strftime(cls._date_format))\n\n    @classmethod\n    def from_today(cls: Type[Self]) -&gt; Self:  # pragma: no cover\n        \"\"\"Instantiates class from today's date.\"\"\"\n        return cls.from_date(date.today())\n\n    @classmethod\n    def from_values(cls: Type[Self], year: int, week: int, weekday: int = 1) -&gt; Self:\n        \"\"\"Parse year, week and weekday values to `_format` format.\"\"\"\n        value = (\n            cls._format.replace(\"YYYY\", str(year).zfill(4))\n            .replace(\"NN\", str(week).zfill(2))\n            .replace(\"D\", str(weekday).zfill(1))\n        )\n        return cls(value)\n\n    @classmethod\n    def _cast(cls: Type[Self], value: IsoWeek_T_contra) -&gt; Self:\n        \"\"\"Tries to cast from different types.\n\n        - `str`: string matching `_pattern`.\n        - `date`: casted to ISO Week by calling `.from_date()` method.\n        - `datetime`: casted to ISO Week by calling `.from_datetime()` method.\n        - `ISOWeek`-like: value will be returned as is.\n\n        Arguments:\n            value: Value to be casted to ISO Week object.\n\n        Returns:\n            `ISOWeek`-like object\n\n        Raises:\n            NotImplementedError: If `value` is not of type `str`, `date`, `datetime` or `ISOWeek`-like.\n\n        Examples:\n        ```py\n        from datetime import date\n        from iso_week_date import IsoWeek\n\n        IsoWeek._cast(\"2023-W01\")  # IsoWeek(\"2023-W01\")\n        ```\n        \"\"\"\n        if isinstance(value, str):\n            return cls.from_string(value)\n        elif isinstance(value, datetime):\n            return cls.from_datetime(value)\n        elif isinstance(value, date):\n            return cls.from_date(value)\n        elif isinstance(value, cls):\n            return value\n        else:\n            msg = f\"Cannot cast type {type(value)} into {cls.__name__}\"\n            raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin.from_compact","title":"<code>from_compact(_str)</code>  <code>classmethod</code>","text":"<p>Parse a string object in <code>_compact_format</code> format.</p> <p>Since values are validated in the initialization method, our goal in this method is to \"add\" the dashes in the appropriate places. To achieve this we:</p> <ul> <li>First check that the length of the string is correct (either 7 or 8).</li> <li>Split the string in 3 parts.</li> <li>Remove (filter) empty values.</li> <li>Finally join them with a dash in between.</li> </ul> Source code in <code>iso_week_date/mixin.py</code> <pre><code>@classmethod\ndef from_compact(cls: Type[Self], _str: str) -&gt; Self:\n    \"\"\"Parse a string object in `_compact_format` format.\n\n    Since values are validated in the initialization method, our goal in this method is to \"add\" the dashes in the\n    appropriate places. To achieve this we:\n\n    - First check that the length of the string is correct (either 7 or 8).\n    - Split the string in 3 parts.\n    - Remove (filter) empty values.\n    - Finally join them with a dash in between.\n    \"\"\"\n    if not isinstance(_str, str):\n        msg = f\"Expected `str` type, found {type(_str)}\"\n        raise TypeError(msg)\n\n    if len(_str) != len(cls._compact_format):\n        raise ValueError(format_err_msg(cls._compact_format, _str))\n\n    split_idx = (0, 4, 7, None)\n    value = \"-\".join(filter(None, (_str[i:j] for i, j in zip(split_idx[:-1], split_idx[1:]))))\n    return cls(value)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin.from_date","title":"<code>from_date(_date)</code>  <code>classmethod</code>","text":"<p>Parse a date object to <code>_date_format</code> after adjusting by <code>offset_</code>.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>@classmethod\ndef from_date(cls: Type[Self], _date: date) -&gt; Self:\n    \"\"\"Parse a date object to `_date_format` after adjusting by `offset_`.\"\"\"\n    if not isinstance(_date, date):\n        msg = f\"Expected `date` type, found {type(_date)}\"\n        raise TypeError(msg)\n    return cls((_date - cls.offset_).strftime(cls._date_format))\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin.from_datetime","title":"<code>from_datetime(_datetime)</code>  <code>classmethod</code>","text":"<p>Parse a datetime object to <code>_date_format</code> after adjusting by <code>offset_</code>.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>@classmethod\ndef from_datetime(cls: Type[Self], _datetime: datetime) -&gt; Self:\n    \"\"\"Parse a datetime object to `_date_format` after adjusting by `offset_`.\"\"\"\n    if not isinstance(_datetime, datetime):\n        msg = f\"Expected `datetime` type, found {type(_datetime)}\"\n        raise TypeError(msg)\n\n    return cls((_datetime - cls.offset_).strftime(cls._date_format))\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin.from_string","title":"<code>from_string(_str)</code>  <code>classmethod</code>","text":"<p>Parse a string object in <code>_pattern</code> format.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>@classmethod\ndef from_string(cls: Type[Self], _str: str) -&gt; Self:\n    \"\"\"Parse a string object in `_pattern` format.\"\"\"\n    if not isinstance(_str, str):\n        msg = f\"Expected `str` type, found {type(_str)}\"\n        raise TypeError(msg)\n    return cls(_str)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin.from_today","title":"<code>from_today()</code>  <code>classmethod</code>","text":"<p>Instantiates class from today's date.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>@classmethod\ndef from_today(cls: Type[Self]) -&gt; Self:  # pragma: no cover\n    \"\"\"Instantiates class from today's date.\"\"\"\n    return cls.from_date(date.today())\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ParserMixin.from_values","title":"<code>from_values(year, week, weekday=1)</code>  <code>classmethod</code>","text":"<p>Parse year, week and weekday values to <code>_format</code> format.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>@classmethod\ndef from_values(cls: Type[Self], year: int, week: int, weekday: int = 1) -&gt; Self:\n    \"\"\"Parse year, week and weekday values to `_format` format.\"\"\"\n    value = (\n        cls._format.replace(\"YYYY\", str(year).zfill(4))\n        .replace(\"NN\", str(week).zfill(2))\n        .replace(\"D\", str(weekday).zfill(1))\n    )\n    return cls(value)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ConverterMixin","title":"<code>iso_week_date.mixin.ConverterMixin</code>","text":"<p>             Bases: <code>IsoWeekProtocol</code></p> <p>Mixin that handles conversion to types.</p> <p><code>ConverterMixin</code> implements <code>to_*</code> methods to convert to the following types:</p> <ul> <li><code>str</code></li> <li><code>date</code></li> <li><code>datetime</code></li> </ul> Source code in <code>iso_week_date/mixin.py</code> <pre><code>class ConverterMixin(IsoWeekProtocol):\n    \"\"\"Mixin that handles conversion to types.\n\n    `ConverterMixin` implements `to_*` methods to convert to the following types:\n\n    - `str`\n    - `date`\n    - `datetime`\n    \"\"\"\n\n    def to_string(self: Self) -&gt; str:\n        \"\"\"Returns as a string in the classical format.\"\"\"\n        return self.value_\n\n    def to_compact(self: Self) -&gt; str:\n        \"\"\"Returns as a string in the compact format.\"\"\"\n        return self.value_.replace(\"-\", \"\")\n\n    def _to_datetime(self: Self, value: str) -&gt; datetime:\n        \"\"\"Converts `value` to `datetime` object and adds the `offset_`.\n\n        !!! warning\n            `value` must be in \"%G-W%V-%u\" format.\n\n            In general this is not always the case and we need to manipulate `value_` attribute before passing it to\n            `datetime.strptime` method.\n        \"\"\"\n        return datetime.strptime(value, \"%G-W%V-%u\") + self.offset_\n\n    def _to_date(self: Self, value: str) -&gt; date:  # pragma: no cover\n        \"\"\"Converts `value` to `date` object and adds the `offset_`.\n\n        !!! warning\n            `value` must be in \"%G-W%V-%u\" format.\n\n            In general this is not always the case and we need to manipulate `value_` attribute before passing it to\n            `datetime.strptime` method.\n        \"\"\"\n        return self._to_datetime(value).date()\n\n    def to_values(self: Self) -&gt; Tuple[int, ...]:\n        \"\"\"Converts `value_` to a tuple of integers (year, week, [weekday]).\"\"\"\n        return tuple(int(v.replace(\"W\", \"\")) for v in self.value_.split(\"-\"))\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ConverterMixin.to_compact","title":"<code>to_compact()</code>","text":"<p>Returns as a string in the compact format.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def to_compact(self: Self) -&gt; str:\n    \"\"\"Returns as a string in the compact format.\"\"\"\n    return self.value_.replace(\"-\", \"\")\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ConverterMixin.to_string","title":"<code>to_string()</code>","text":"<p>Returns as a string in the classical format.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def to_string(self: Self) -&gt; str:\n    \"\"\"Returns as a string in the classical format.\"\"\"\n    return self.value_\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ConverterMixin.to_values","title":"<code>to_values()</code>","text":"<p>Converts <code>value_</code> to a tuple of integers (year, week, [weekday]).</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def to_values(self: Self) -&gt; Tuple[int, ...]:\n    \"\"\"Converts `value_` to a tuple of integers (year, week, [weekday]).\"\"\"\n    return tuple(int(v.replace(\"W\", \"\")) for v in self.value_.split(\"-\"))\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin","title":"<code>iso_week_date.mixin.ComparatorMixin</code>","text":"<p>             Bases: <code>IsoWeekProtocol</code></p> <p>Mixin that implements comparison operators (\"==\", \"!=\", \"&lt;\", \"&lt;=\", \"&gt;\", \"&gt;=\") between two ISO Week objects.</p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>class ComparatorMixin(IsoWeekProtocol):\n    \"\"\"Mixin that implements comparison operators (\"==\", \"!=\", \"&lt;\", \"&lt;=\", \"&gt;\", \"&gt;=\") between two ISO Week objects.\"\"\"\n\n    def __eq__(self: Self, other: object) -&gt; bool:\n        \"\"\"Equality operator.\n\n        Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if objects are equal, `False` otherwise.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") == IsoWeek(\"2023-W01\")  # True\n        IsoWeek(\"2023-W01\") == IsoWeek(\"2023-W02\")  # False\n\n        class CustomIsoWeek(IsoWeek):\n            offset_ = timedelta(days=1)\n\n        IsoWeek(\"2023-W01\") == CustomIsoWeek(\"2023-W01\")  # False\n        ```\n        \"\"\"\n        if isinstance(other, self.__class__):\n            return (self.offset_ == other.offset_) and (self.value_ == other.value_)\n        else:\n            return False\n\n    def __ne__(self: Self, other: object) -&gt; bool:\n        \"\"\"Inequality operator.\n\n        Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if objects are _not_ equal, `False` otherwise.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") != IsoWeek(\"2023-W01\")  # False\n        IsoWeek(\"2023-W01\") != IsoWeek(\"2023-W02\")  # True\n\n        class CustomIsoWeek(IsoWeek):\n            offset_ = timedelta(days=1)\n\n        IsoWeek(\"2023-W01\") != CustomIsoWeek(\"2023-W01\")  # True\n        ```\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __lt__(self: Self, other: Self) -&gt; bool:\n        \"\"\"Less than operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is less than other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") &lt; IsoWeek(\"2023-W02\")  # True\n        IsoWeek(\"2023-W02\") &lt; IsoWeek(\"2023-W01\")  # False\n\n        class CustomIsoWeek(IsoWeek):\n            offset_ = timedelta(days=1)\n\n        IsoWeek(\"2023-W01\") &lt; CustomIsoWeek(\"2023-W01\")  # TypeError\n        IsoWeek(\"2023-W01\") &lt; \"2023-W01\"  # TypeError\n        ```\n        \"\"\"\n        if isinstance(other, self.__class__):\n            if self.offset_ == other.offset_:\n                return self.value_ &lt; other.value_\n            else:\n                msg = f\"Cannot compare `{self.name}`'s with different offsets\"\n                raise TypeError(msg)\n        else:\n            msg = (\n                f\"Cannot compare `{self.name}` with type `{type(other)}`, comparison is supported only with other \"\n                f\"`{self.name}` objects\"\n            )\n            raise TypeError(msg)\n\n    def __le__(self: Self, other: Self) -&gt; bool:\n        \"\"\"Less than or equal operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is less than or equal to other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") &lt;= IsoWeek(\"2023-W01\")  # True\n        IsoWeek(\"2023-W02\") &lt;= IsoWeek(\"2023-W01\")  # False\n\n        class CustomIsoWeek(IsoWeek):\n            offset_ = timedelta(days=1)\n\n        IsoWeek(\"2023-W01\") &lt;= CustomIsoWeek(\"2023-W01\")  # TypeError\n        IsoWeek(\"2023-W01\") &lt;= \"2023-W01\"  # TypeError\n        ```\n        \"\"\"\n        return self.__lt__(other) or self.__eq__(other)\n\n    def __gt__(self: Self, other: Self) -&gt; bool:\n        \"\"\"Greater than operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is greater than other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") &gt;= IsoWeek(\"2023-W02\")  # False\n        IsoWeek(\"2023-W01\") &gt;= IsoWeek(\"2023-W01\")  # True\n\n        class CustomIsoWeek(IsoWeek):\n            offset_ = timedelta(days=1)\n\n        IsoWeek(\"2023-W01\") &gt;= CustomIsoWeek(\"2023-W01\")  # TypeError\n        IsoWeek(\"2023-W01\") &gt;= \"2023-W01\"  # TypeError\n        ```\n        \"\"\"\n        return not self.__le__(other)\n\n    def __ge__(self: Self, other: Self) -&gt; bool:\n        \"\"\"Greater than or equal operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n           other: Object to compare with.\n\n        Returns:\n            `True` if self is greater than or equal to `other`, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n        ```py\n        from datetime import timedelta\n        from iso_week_date import IsoWeek\n\n        IsoWeek(\"2023-W01\") &gt; IsoWeek(\"2023-W02\")  # False\n        IsoWeek(\"2023-W02\") &gt; IsoWeek(\"2023-W01\")  # True\n\n        class CustomIsoWeek(IsoWeek):\n            offset_ = timedelta(days=1)\n\n        IsoWeek(\"2023-W01\") &gt; CustomIsoWeek(\"2023-W01\")  # TypeError\n        IsoWeek(\"2023-W01\") &gt; \"2023-W01\"  # TypeError\n        ```\n        \"\"\"\n        return not self.__lt__(other)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality operator.</p> <p>Two ISO Week objects are considered equal if and only if they have the same <code>offset_</code> and the same <code>value_</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if objects are equal, <code>False</code> otherwise.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") == IsoWeek(\"2023-W01\")  # True\nIsoWeek(\"2023-W01\") == IsoWeek(\"2023-W02\")  # False\n\nclass CustomIsoWeek(IsoWeek):\n    offset_ = timedelta(days=1)\n\nIsoWeek(\"2023-W01\") == CustomIsoWeek(\"2023-W01\")  # False\n</code></pre></p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def __eq__(self: Self, other: object) -&gt; bool:\n    \"\"\"Equality operator.\n\n    Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if objects are equal, `False` otherwise.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") == IsoWeek(\"2023-W01\")  # True\n    IsoWeek(\"2023-W01\") == IsoWeek(\"2023-W02\")  # False\n\n    class CustomIsoWeek(IsoWeek):\n        offset_ = timedelta(days=1)\n\n    IsoWeek(\"2023-W01\") == CustomIsoWeek(\"2023-W01\")  # False\n    ```\n    \"\"\"\n    if isinstance(other, self.__class__):\n        return (self.offset_ == other.offset_) and (self.value_ == other.value_)\n    else:\n        return False\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Greater than or equal operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is greater than or equal to <code>other</code>, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") &gt; IsoWeek(\"2023-W02\")  # False\nIsoWeek(\"2023-W02\") &gt; IsoWeek(\"2023-W01\")  # True\n\nclass CustomIsoWeek(IsoWeek):\n    offset_ = timedelta(days=1)\n\nIsoWeek(\"2023-W01\") &gt; CustomIsoWeek(\"2023-W01\")  # TypeError\nIsoWeek(\"2023-W01\") &gt; \"2023-W01\"  # TypeError\n</code></pre></p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def __ge__(self: Self, other: Self) -&gt; bool:\n    \"\"\"Greater than or equal operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n       other: Object to compare with.\n\n    Returns:\n        `True` if self is greater than or equal to `other`, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") &gt; IsoWeek(\"2023-W02\")  # False\n    IsoWeek(\"2023-W02\") &gt; IsoWeek(\"2023-W01\")  # True\n\n    class CustomIsoWeek(IsoWeek):\n        offset_ = timedelta(days=1)\n\n    IsoWeek(\"2023-W01\") &gt; CustomIsoWeek(\"2023-W01\")  # TypeError\n    IsoWeek(\"2023-W01\") &gt; \"2023-W01\"  # TypeError\n    ```\n    \"\"\"\n    return not self.__lt__(other)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Greater than operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is greater than other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") &gt;= IsoWeek(\"2023-W02\")  # False\nIsoWeek(\"2023-W01\") &gt;= IsoWeek(\"2023-W01\")  # True\n\nclass CustomIsoWeek(IsoWeek):\n    offset_ = timedelta(days=1)\n\nIsoWeek(\"2023-W01\") &gt;= CustomIsoWeek(\"2023-W01\")  # TypeError\nIsoWeek(\"2023-W01\") &gt;= \"2023-W01\"  # TypeError\n</code></pre></p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def __gt__(self: Self, other: Self) -&gt; bool:\n    \"\"\"Greater than operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is greater than other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") &gt;= IsoWeek(\"2023-W02\")  # False\n    IsoWeek(\"2023-W01\") &gt;= IsoWeek(\"2023-W01\")  # True\n\n    class CustomIsoWeek(IsoWeek):\n        offset_ = timedelta(days=1)\n\n    IsoWeek(\"2023-W01\") &gt;= CustomIsoWeek(\"2023-W01\")  # TypeError\n    IsoWeek(\"2023-W01\") &gt;= \"2023-W01\"  # TypeError\n    ```\n    \"\"\"\n    return not self.__le__(other)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin.__le__","title":"<code>__le__(other)</code>","text":"<p>Less than or equal operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is less than or equal to other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") &lt;= IsoWeek(\"2023-W01\")  # True\nIsoWeek(\"2023-W02\") &lt;= IsoWeek(\"2023-W01\")  # False\n\nclass CustomIsoWeek(IsoWeek):\n    offset_ = timedelta(days=1)\n\nIsoWeek(\"2023-W01\") &lt;= CustomIsoWeek(\"2023-W01\")  # TypeError\nIsoWeek(\"2023-W01\") &lt;= \"2023-W01\"  # TypeError\n</code></pre></p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def __le__(self: Self, other: Self) -&gt; bool:\n    \"\"\"Less than or equal operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is less than or equal to other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") &lt;= IsoWeek(\"2023-W01\")  # True\n    IsoWeek(\"2023-W02\") &lt;= IsoWeek(\"2023-W01\")  # False\n\n    class CustomIsoWeek(IsoWeek):\n        offset_ = timedelta(days=1)\n\n    IsoWeek(\"2023-W01\") &lt;= CustomIsoWeek(\"2023-W01\")  # TypeError\n    IsoWeek(\"2023-W01\") &lt;= \"2023-W01\"  # TypeError\n    ```\n    \"\"\"\n    return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Less than operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is less than other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") &lt; IsoWeek(\"2023-W02\")  # True\nIsoWeek(\"2023-W02\") &lt; IsoWeek(\"2023-W01\")  # False\n\nclass CustomIsoWeek(IsoWeek):\n    offset_ = timedelta(days=1)\n\nIsoWeek(\"2023-W01\") &lt; CustomIsoWeek(\"2023-W01\")  # TypeError\nIsoWeek(\"2023-W01\") &lt; \"2023-W01\"  # TypeError\n</code></pre></p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def __lt__(self: Self, other: Self) -&gt; bool:\n    \"\"\"Less than operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is less than other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") &lt; IsoWeek(\"2023-W02\")  # True\n    IsoWeek(\"2023-W02\") &lt; IsoWeek(\"2023-W01\")  # False\n\n    class CustomIsoWeek(IsoWeek):\n        offset_ = timedelta(days=1)\n\n    IsoWeek(\"2023-W01\") &lt; CustomIsoWeek(\"2023-W01\")  # TypeError\n    IsoWeek(\"2023-W01\") &lt; \"2023-W01\"  # TypeError\n    ```\n    \"\"\"\n    if isinstance(other, self.__class__):\n        if self.offset_ == other.offset_:\n            return self.value_ &lt; other.value_\n        else:\n            msg = f\"Cannot compare `{self.name}`'s with different offsets\"\n            raise TypeError(msg)\n    else:\n        msg = (\n            f\"Cannot compare `{self.name}` with type `{type(other)}`, comparison is supported only with other \"\n            f\"`{self.name}` objects\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/mixins/#iso_week_date.mixin.ComparatorMixin.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Inequality operator.</p> <p>Two ISO Week objects are considered equal if and only if they have the same <code>offset_</code> and the same <code>value_</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if objects are not equal, <code>False</code> otherwise.</p> <p>Examples: <pre><code>from datetime import timedelta\nfrom iso_week_date import IsoWeek\n\nIsoWeek(\"2023-W01\") != IsoWeek(\"2023-W01\")  # False\nIsoWeek(\"2023-W01\") != IsoWeek(\"2023-W02\")  # True\n\nclass CustomIsoWeek(IsoWeek):\n    offset_ = timedelta(days=1)\n\nIsoWeek(\"2023-W01\") != CustomIsoWeek(\"2023-W01\")  # True\n</code></pre></p> Source code in <code>iso_week_date/mixin.py</code> <pre><code>def __ne__(self: Self, other: object) -&gt; bool:\n    \"\"\"Inequality operator.\n\n    Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if objects are _not_ equal, `False` otherwise.\n\n    Examples:\n    ```py\n    from datetime import timedelta\n    from iso_week_date import IsoWeek\n\n    IsoWeek(\"2023-W01\") != IsoWeek(\"2023-W01\")  # False\n    IsoWeek(\"2023-W01\") != IsoWeek(\"2023-W02\")  # True\n\n    class CustomIsoWeek(IsoWeek):\n        offset_ = timedelta(days=1)\n\n    IsoWeek(\"2023-W01\") != CustomIsoWeek(\"2023-W01\")  # True\n    ```\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"api/pandas/","title":"Pandas utils module","text":""},{"location":"api/pandas/#functions","title":"Functions","text":""},{"location":"api/pandas/#iso_week_date.pandas_utils.datetime_to_isoweek","title":"<code>iso_week_date.pandas_utils.datetime_to_isoweek(series, offset=0)</code>","text":"<p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>series of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series with converted ISO Week values (in format YYYY-WNN)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>series</code> values are not <code>datetime</code>-like</li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <p>Examples: <pre><code>from datetime import date\nimport pandas as pd\nfrom iso_week_date.pandas_utils import datetime_to_isoweek\n\ns = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ndatetime_to_isoweek(series=s, offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweek(series: pd.Series, offset: OffsetType = 0) -&gt; pd.Series:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        series: series of `date` or `datetime` values\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series with converted ISO Week values (in format YYYY-WNN)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `series` values are not `datetime`-like\n            - `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date\n    import pandas as pd\n    from iso_week_date.pandas_utils import datetime_to_isoweek\n\n    s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n    datetime_to_isoweek(series=s, offset=pd.Timedelta(days=1)).to_list()\n    # ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n    ```\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEK__DATE_FORMAT)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.datetime_to_isoweekdate","title":"<code>iso_week_date.pandas_utils.datetime_to_isoweekdate(series, offset=0)</code>","text":"<p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>series of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series with converted ISO Week date values (in format YYYY-WNN-D)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>series</code> values are not <code>datetime</code>-like</li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <p>Examples: <pre><code>from datetime import date\nimport pandas as pd\nfrom iso_week_date.pandas_utils import datetime_to_isoweekdate\n\ns = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ndatetime_to_isoweekdate(series=s, offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweekdate(series: pd.Series, offset: OffsetType = 0) -&gt; pd.Series:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        series: series of `date` or `datetime` values\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series with converted ISO Week date values (in format YYYY-WNN-D)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `series` values are not `datetime`-like\n            - `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date\n    import pandas as pd\n    from iso_week_date.pandas_utils import datetime_to_isoweekdate\n\n    s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n    datetime_to_isoweekdate(series=s, offset=pd.Timedelta(days=1)).to_list()\n    # ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n    ```\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEKDATE__DATE_FORMAT)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.isoweek_to_datetime","title":"<code>iso_week_date.pandas_utils.isoweek_to_datetime(series, offset=0, weekday=1, *, strict=True)</code>","text":"<p>Converts series of <code>str</code> values in ISO Week format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series of <code>str</code> values in ISO Week format.</p> required <code>offset</code> <code>OffsetType</code> <p>Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7).</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples: <pre><code>import pandas as pd\n\nfrom iso_week_date.pandas_utils import isoweek_to_datetime\n\ns = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\nisoweek_to_datetime(series=s, offset=pd.Timedelta(days=1))\n'''\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n'''\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweek_to_datetime(\n    series: pd.Series,\n    offset: OffsetType = 0,\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; pd.Series:\n    \"\"\"Converts series of `str` values in ISO Week format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        series: Series of `str` values in ISO Week format.\n        offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7).\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `offset` is not of type `pd.Timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n    ```py\n    import pandas as pd\n\n    from iso_week_date.pandas_utils import isoweek_to_datetime\n\n    s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    isoweek_to_datetime(series=s, offset=pd.Timedelta(days=1))\n    '''\n    0   2022-12-27\n    1   2023-01-03\n    2   2023-01-10\n    dtype: datetime64[ns]\n    '''\n    ```\n    \"\"\"\n    if not isinstance(offset, (pd.Timedelta, int)):\n        msg = f\"`offset` must be of type `pd.Timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    if weekday not in range(1, 8):\n        msg = f\"`weekday` value must be an integer between 1 and 7, found {weekday}\"\n        raise ValueError(msg)\n\n    _offset = pd.Timedelta(days=offset) if isinstance(offset, int) else offset\n    errors = \"raise\" if strict else \"coerce\"\n    return pd.to_datetime(series + \"-\" + f\"{weekday}\", errors=errors, format=ISOWEEKDATE__DATE_FORMAT) + _offset\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.isoweekdate_to_datetime","title":"<code>iso_week_date.pandas_utils.isoweekdate_to_datetime(series, offset=0, *, strict=True)</code>","text":"<p>Converts series of <code>str</code> values in ISO Week date format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>series of <code>str</code> in ISO Week date format.</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If one of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <p>Examples: <pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import isoweekdate_to_datetime\n\ns = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\nisoweekdate_to_datetime(series=s, offset=pd.Timedelta(days=1))\n'''\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n'''\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweekdate_to_datetime(\n    series: pd.Series,\n    offset: OffsetType = 0,\n    *,\n    strict: bool = True,\n) -&gt; pd.Series:\n    \"\"\"Converts series of `str` values in ISO Week date format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    Arguments:\n        series: series of `str` in ISO Week date format.\n        offset: offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If one of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n    ```py\n    import pandas as pd\n    from iso_week_date.pandas_utils import isoweekdate_to_datetime\n\n    s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n    isoweekdate_to_datetime(series=s, offset=pd.Timedelta(days=1))\n    '''\n    0   2022-12-27\n    1   2023-01-03\n    2   2023-01-10\n    dtype: datetime64[ns]\n    '''\n    ```\n    \"\"\"\n    if not isinstance(offset, (pd.Timedelta, int)):\n        msg = f\"`offset` must be of type `pd.Timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    _offset = pd.Timedelta(days=offset) if isinstance(offset, int) else offset\n    errors = \"raise\" if strict else \"coerce\"\n    return pd.to_datetime(series, errors=errors, format=ISOWEEKDATE__DATE_FORMAT) + _offset\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.is_isoweek_series","title":"<code>iso_week_date.pandas_utils.is_isoweek_series(series)</code>","text":"<p>Checks if <code>series</code> contains only values in ISO Week format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>series of <code>str</code> values to check against \"YYYY-WNN\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pd.Series</code></p> <p>Examples: <pre><code>import pandas as pd\n\nfrom iso_week_date.pandas_utils import is_isoweek_series\n\ns = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\nis_isoweek_series(series=s)  # True\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweek_series(series: pd.Series) -&gt; bool:\n    \"\"\"Checks if `series` contains only values in ISO Week format.\n\n    Arguments:\n        series: series of `str` values to check against \"YYYY-WNN\" pattern\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pd.Series`\n\n    Examples:\n    ```py\n    import pandas as pd\n\n    from iso_week_date.pandas_utils import is_isoweek_series\n\n    s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    is_isoweek_series(series=s)  # True\n    ```\n    \"\"\"\n    return _match_series(series, ISOWEEK_PATTERN.pattern)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.is_isoweekdate_series","title":"<code>iso_week_date.pandas_utils.is_isoweekdate_series(series)</code>","text":"<p>Checks if <code>series</code> contains only values in ISO Week date format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>series of <code>str</code> values to check against \"YYYY-WNN-D\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pd.Series</code></p> <p>Examples: <pre><code>import pandas as pd\n\nfrom iso_week_date.pandas_utils import is_isoweekdate_series\n\ns = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\nis_isoweekdate_series(series=s)  # True\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweekdate_series(series: pd.Series) -&gt; bool:\n    \"\"\"Checks if `series` contains only values in ISO Week date format.\n\n    Arguments:\n        series: series of `str` values to check against \"YYYY-WNN-D\" pattern\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pd.Series`\n\n    Examples:\n    ```py\n    import pandas as pd\n\n    from iso_week_date.pandas_utils import is_isoweekdate_series\n\n    s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n    is_isoweekdate_series(series=s)  # True\n    ```\n    \"\"\"\n    return _match_series(series, ISOWEEKDATE_PATTERN.pattern)\n</code></pre>"},{"location":"api/pandas/#series-extension","title":"Series extension","text":""},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek","title":"<code>iso_week_date.pandas_utils.SeriesIsoWeek</code>","text":"<p>Pandas Series extension that provides methods for working with ISO weeks and dates.</p> <p>Instead of importing and working with single functions from the <code>pandas_utils</code> module, it is possible to import the Series extension class to be able to use the functions as methods on Series objects.</p> <p>To accomplish this, it is enough to load <code>SeriesIsoWeek</code> into scope:</p> <p><pre><code>from datetime import date\nimport pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ns.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n</code></pre> Parameters:     series: The pandas Series object the extension is attached to.</p> <p>Attributes:</p> Name Type Description <code>_series</code> <code>Series</code> <p>The pandas Series object the extension is attached to.</p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"iwd\")\nclass SeriesIsoWeek:\n    \"\"\"Pandas Series extension that provides methods for working with ISO weeks and dates.\n\n    Instead of importing and working with single functions from the `pandas_utils` module, it is possible to import the\n    Series [extension class](https://pandas.pydata.org/docs/development/extending.html) to be able to use the functions\n    as methods on Series objects.\n\n    To accomplish this, it is enough to load `SeriesIsoWeek` into scope:\n\n    ```python hl_lines=\"3 6\"\n    from datetime import date\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n    s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n    # ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n    ```\n    Parameters:\n        series: The pandas Series object the extension is attached to.\n\n    Attributes:\n        _series: The pandas Series object the extension is attached to.\n    \"\"\"\n\n    def __init__(self: Self, series: pd.Series) -&gt; None:\n        self._series: pd.Series = series\n\n    def datetime_to_isoweek(self: Self, offset: OffsetType = 0) -&gt; pd.Series:\n        \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week format YYYY-WNN.\n\n        Arguments:\n            offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n                to ISO Week, it can be negative\n\n        Returns:\n            ISO Week pandas series in format YYYY-WNN\n\n        Raises:\n            TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n        Examples:\n        ```py\n        from datetime import date\n        import pandas as pd\n        from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n        s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n        # ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n        ```\n        \"\"\"\n        return datetime_to_isoweek(self._series, offset=offset)\n\n    def datetime_to_isoweekdate(self: Self, offset: OffsetType = 0) -&gt; pd.Series:\n        \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week date format YYYY-WNN-D.\n\n        Arguments:\n            offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n                to ISO Week, it can be negative\n\n        Returns:\n            ISO Week date pandas series in format YYYY-WNN-D\n\n        Raises:\n            TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n        Examples:\n        ```py\n        from datetime import date\n        import pandas as pd\n        from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n        s.iwd.datetime_to_isoweekdate(offset=pd.Timedelta(days=1)).to_list()\n        # ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n        ```\n        \"\"\"\n        return datetime_to_isoweekdate(self._series, offset=offset)\n\n    def isoweek_to_datetime(\n        self: Self,\n        offset: OffsetType = 0,\n        weekday: int = 1,\n        *,\n        strict: bool = True,\n    ) -&gt; pd.Series:\n        \"\"\"Converts series of `str` values in ISO Week format to a series of `datetime` values.\n\n        `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n        `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n        week, 7 is the last one.\n\n        Arguments:\n            offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            weekday: Weekday to use for conversion (1-7).\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series of converted datetime values\n\n        Raises:\n            TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n            ValueError: If `weekday` is not an integer between 1 and 7\n\n        Examples:\n        ```py\n        import pandas as pd\n        from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        s.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n        '''\n        0   2022-12-27\n        1   2023-01-03\n        2   2023-01-10\n        dtype: datetime64[ns]\n        '''\n        ```\n        \"\"\"\n        return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)\n\n    def isoweekdate_to_datetime(self: Self, offset: OffsetType = 0, *, strict: bool = True) -&gt; pd.Series:\n        \"\"\"Converts series of `str` values in ISO Week date format to a series of `datetime` values.\n\n        `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n        Arguments:\n            offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series of converted datetime values\n\n        Raises:\n            TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n            ValueError: If `weekday` is not an integer between 1 and 7\n\n        Examples:\n        ```py\n        import pandas as pd\n        from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        s.iwd.isoweekdate_to_datetime(offset=pd.Timedelta(days=1))\n        '''\n        0   2022-12-27\n        1   2023-01-03\n        2   2023-01-10\n        dtype: datetime64[ns]\n        '''\n        ```\n        \"\"\"\n        return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)\n\n    def is_isoweek(self: Self) -&gt; bool:\n        \"\"\"Checks if series contains only values in ISO Week format.\n\n        Returns:\n            `True` if all values match ISO Week format, `False` otherwise\n\n        Examples:\n        ```py\n        import pandas as pd\n        from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        s.iwd.is_isoweek()  # True\n        ```\n        \"\"\"\n        return is_isoweek_series(self._series)\n\n    def is_isoweekdate(self: Self) -&gt; bool:\n        \"\"\"Checks if series contains only values in ISO Week date format.\n\n        Returns:\n            `True` if all values match ISO Week date format, `False` otherwise\n\n        Examples:\n        ```py\n        import pandas as pd\n        from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        s.iwd.is_isoweekdate()  # True\n        ```\n        \"\"\"\n        return is_isoweekdate_series(self._series)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.datetime_to_isoweek","title":"<code>datetime_to_isoweek(offset=0)</code>","text":"<p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series</code> <p>ISO Week pandas series in format YYYY-WNN</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If series values are not <code>datetime</code>, or if <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <p>Examples: <pre><code>from datetime import date\nimport pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ns.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweek(self: Self, offset: OffsetType = 0) -&gt; pd.Series:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n            to ISO Week, it can be negative\n\n    Returns:\n        ISO Week pandas series in format YYYY-WNN\n\n    Raises:\n        TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n    s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n    # ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n    ```\n    \"\"\"\n    return datetime_to_isoweek(self._series, offset=offset)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.datetime_to_isoweekdate","title":"<code>datetime_to_isoweekdate(offset=0)</code>","text":"<p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series</code> <p>ISO Week date pandas series in format YYYY-WNN-D</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If series values are not <code>datetime</code>, or if <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <p>Examples: <pre><code>from datetime import date\nimport pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ns.iwd.datetime_to_isoweekdate(offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweekdate(self: Self, offset: OffsetType = 0) -&gt; pd.Series:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n            to ISO Week, it can be negative\n\n    Returns:\n        ISO Week date pandas series in format YYYY-WNN-D\n\n    Raises:\n        TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n    s.iwd.datetime_to_isoweekdate(offset=pd.Timedelta(days=1)).to_list()\n    # ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n    ```\n    \"\"\"\n    return datetime_to_isoweekdate(self._series, offset=offset)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.is_isoweek","title":"<code>is_isoweek()</code>","text":"<p>Checks if series contains only values in ISO Week format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Examples: <pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\ns.iwd.is_isoweek()  # True\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweek(self: Self) -&gt; bool:\n    \"\"\"Checks if series contains only values in ISO Week format.\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Examples:\n    ```py\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    s.iwd.is_isoweek()  # True\n    ```\n    \"\"\"\n    return is_isoweek_series(self._series)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.is_isoweekdate","title":"<code>is_isoweekdate()</code>","text":"<p>Checks if series contains only values in ISO Week date format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Examples: <pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\ns.iwd.is_isoweekdate()  # True\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweekdate(self: Self) -&gt; bool:\n    \"\"\"Checks if series contains only values in ISO Week date format.\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Examples:\n    ```py\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n    s.iwd.is_isoweekdate()  # True\n    ```\n    \"\"\"\n    return is_isoweekdate_series(self._series)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.isoweek_to_datetime","title":"<code>isoweek_to_datetime(offset=0, weekday=1, *, strict=True)</code>","text":"<p>Converts series of <code>str</code> values in ISO Week format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7).</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples: <pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\ns.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n'''\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n'''\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweek_to_datetime(\n    self: Self,\n    offset: OffsetType = 0,\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; pd.Series:\n    \"\"\"Converts series of `str` values in ISO Week format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7).\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n    ```py\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    s.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n    '''\n    0   2022-12-27\n    1   2023-01-03\n    2   2023-01-10\n    dtype: datetime64[ns]\n    '''\n    ```\n    \"\"\"\n    return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.isoweekdate_to_datetime","title":"<code>isoweekdate_to_datetime(offset=0, *, strict=True)</code>","text":"<p>Converts series of <code>str</code> values in ISO Week date format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples: <pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\ns.iwd.isoweekdate_to_datetime(offset=pd.Timedelta(days=1))\n'''\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n'''\n</code></pre></p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweekdate_to_datetime(self: Self, offset: OffsetType = 0, *, strict: bool = True) -&gt; pd.Series:\n    \"\"\"Converts series of `str` values in ISO Week date format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    Arguments:\n        offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n    ```py\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n    s.iwd.isoweekdate_to_datetime(offset=pd.Timedelta(days=1))\n    '''\n    0   2022-12-27\n    1   2023-01-03\n    2   2023-01-10\n    dtype: datetime64[ns]\n    '''\n    ```\n    \"\"\"\n    return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)\n</code></pre>"},{"location":"api/polars/","title":"Polars utils module","text":""},{"location":"api/polars/#functions","title":"Functions","text":""},{"location":"api/polars/#iso_week_date.polars_utils.datetime_to_isoweek","title":"<code>iso_week_date.polars_utils.datetime_to_isoweek(series, offset=timedelta(days=0))</code>","text":"<p>Converts <code>date(time)</code> <code>series/expr</code> to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>T</code> <p>series or expr of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(days=0)</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <p>Examples: <pre><code>from datetime import date, timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import datetime_to_isoweek\n\ns = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ndatetime_to_isoweek(s, offset=timedelta(days=1))\n\ndf = pl.DataFrame({\"date\": s})\ndf.select(datetime_to_isoweek(pl.col(\"date\"), offset=1))\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweek(series: T, offset: OffsetType = timedelta(days=0)) -&gt; T:\n    \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        series: series or expr of `date` or `datetime` values\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to ISO\n            Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date, timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import datetime_to_isoweek\n\n    s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n    datetime_to_isoweek(s, offset=timedelta(days=1))\n\n    df = pl.DataFrame({\"date\": s})\n    df.select(datetime_to_isoweek(pl.col(\"date\"), offset=1))\n    ```\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEK__DATE_FORMAT)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.datetime_to_isoweekdate","title":"<code>iso_week_date.polars_utils.datetime_to_isoweekdate(series, offset=timedelta(days=0))</code>","text":"<p>Converts <code>date(time)</code> <code>series/expr</code>  to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>T</code> <p>series or expr of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(days=0)</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN-D)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <p>Examples: <pre><code>from datetime import date, timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import datetime_to_isoweekdate\n\ns = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ndatetime_to_isoweekdate(s, offset=timedelta(days=1))\n\ndf = pl.DataFrame({\"date\": s})\ndf.select(datetime_to_isoweekdate(pl.col(\"date\"), offset=1))\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweekdate(series: T, offset: OffsetType = timedelta(days=0)) -&gt; T:\n    \"\"\"Converts `date(time)` `series/expr`  to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        series: series or expr of `date` or `datetime` values\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to ISO\n            Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN-D)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date, timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import datetime_to_isoweekdate\n\n    s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n    datetime_to_isoweekdate(s, offset=timedelta(days=1))\n\n    df = pl.DataFrame({\"date\": s})\n    df.select(datetime_to_isoweekdate(pl.col(\"date\"), offset=1))\n    ```\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEKDATE__DATE_FORMAT)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.isoweek_to_datetime","title":"<code>iso_week_date.polars_utils.isoweek_to_datetime(series, offset=timedelta(days=0), weekday=1, *, strict=True)</code>","text":"<p>Converts series or expr of <code>str</code> values in ISO Week format YYYY-WNN to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>T</code> <p>Series or Expr of <code>str</code> values in ISO Week format.</p> required <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>timedelta(days=0)</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7)</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples: <pre><code>from datetime import timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import isoweek_to_datetime\n\ns = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\nisoweek_to_datetime(series=s, offset=timedelta(days=1))\n'''\ndate\n2022-12-27\n2023-01-03\n2023-01-10\n'''\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweek_to_datetime(\n    series: T,\n    offset: OffsetType = timedelta(days=0),\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; T:\n    \"\"\"Converts series or expr of `str` values in ISO Week format YYYY-WNN to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        series: Series or Expr of `str` values in ISO Week format.\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7)\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n    ```py\n    from datetime import timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import isoweek_to_datetime\n\n    s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    isoweek_to_datetime(series=s, offset=timedelta(days=1))\n    '''\n    date\n    2022-12-27\n    2023-01-03\n    2023-01-10\n    '''\n    ```\n    \"\"\"\n    if not isinstance(offset, (timedelta, int)):\n        msg = f\"`offset` must be of type `timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    if weekday not in range(1, 8):\n        msg = f\"`weekday` value must be an integer between 1 and 7, found {weekday}\"\n        raise ValueError(msg)\n\n    _offset = timedelta(days=offset) if isinstance(offset, int) else offset\n\n    return (series + f\"-{weekday}\").str.strptime(pl.Date, ISOWEEKDATE__DATE_FORMAT, strict=strict) + _offset\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.isoweekdate_to_datetime","title":"<code>iso_week_date.polars_utils.isoweekdate_to_datetime(series, offset=timedelta(days=0), *, strict=True)</code>","text":"<p>Converts <code>series/expr</code> of values in ISO Week date format YYYY-WNN-D to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>T</code> <p>Series or Expr of <code>str</code> values in ISO Week date format</p> required <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative</p> <code>timedelta(days=0)</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <p>Examples: <pre><code>from datetime import timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import isoweekdate_to_datetime\n\ns = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\nisoweekdate_to_datetime(series=s, offset=timedelta(days=1))\n'''\ndate\n2022-01-02\n2023-01-03\n2023-01-10\n'''\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweekdate_to_datetime(\n    series: T,\n    offset: OffsetType = timedelta(days=0),\n    *,\n    strict: bool = True,\n) -&gt; T:\n    \"\"\"Converts `series/expr` of values in ISO Week date format YYYY-WNN-D to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    Arguments:\n        series: Series or Expr of `str` values in ISO Week date format\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import isoweekdate_to_datetime\n\n    s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n    isoweekdate_to_datetime(series=s, offset=timedelta(days=1))\n    '''\n    date\n    2022-01-02\n    2023-01-03\n    2023-01-10\n    '''\n    ```\n    \"\"\"\n    if not isinstance(offset, (timedelta, int)):\n        msg = f\"`offset` must be of type `timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    _offset = timedelta(days=offset) if isinstance(offset, int) else offset\n\n    return series.str.strptime(pl.Date, ISOWEEKDATE__DATE_FORMAT, strict=strict) + _offset\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.is_isoweek_series","title":"<code>iso_week_date.polars_utils.is_isoweek_series(series)</code>","text":"<p>Checks if a series or expr contains only values in ISO Week format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>T</code> <p>series or expr of <code>str</code> values to check against \"YYYY-WNN\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></p> <p>Examples: <pre><code>import polars as pl\nfrom iso_week_date.polars_utils import is_isoweek_series\n\ns = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\nis_isoweek_series(s) # True\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweek_series(series: T) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week format.\n\n    Arguments:\n        series: series or expr of `str` values to check against \"YYYY-WNN\" pattern\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pl.Series` or `pl.Expr`\n\n    Examples:\n    ```py\n    import polars as pl\n    from iso_week_date.polars_utils import is_isoweek_series\n\n    s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    is_isoweek_series(s) # True\n    ```\n    \"\"\"\n    return _match_series(series, ISOWEEK_PATTERN.pattern)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.is_isoweekdate_series","title":"<code>iso_week_date.polars_utils.is_isoweekdate_series(series)</code>","text":"<p>Checks if a series or expr contains only values in ISO Week date format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>T</code> <p>series or expr of <code>str</code> values to check against \"YYYY-WNN-D\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></p> <p>Examples: <pre><code>import polars as pl\nfrom iso_week_date.polars_utils import is_isoweekdate_series\n\ns = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\nis_isoweekdate_series(series=s)  # True\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweekdate_series(series: T) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week date format.\n\n    Arguments:\n        series: series or expr of `str` values to check against \"YYYY-WNN-D\" pattern\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pl.Series` or `pl.Expr`\n\n    Examples:\n    ```py\n    import polars as pl\n    from iso_week_date.polars_utils import is_isoweekdate_series\n\n    s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n    is_isoweekdate_series(series=s)  # True\n    ```\n    \"\"\"\n    return _match_series(series, ISOWEEKDATE_PATTERN.pattern)\n</code></pre>"},{"location":"api/polars/#series-extension","title":"Series extension","text":""},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek","title":"<code>iso_week_date.polars_utils.SeriesIsoWeek</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>Polars Series and Expr extension that provides methods for working with ISO weeks and dates.</p> <p>Instead of importing and working with single functions from the <code>polars_utils</code> module, it is possible to import the Series and Expr extension class to be able to use the functions as methods on Series and Expr objects.</p> <p>To accomplish this, it is enough to load <code>SeriesIsoWeek</code> into scope:</p> <p><pre><code>from datetime import date, timedelta\nimport polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ns.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\ndf = pl.DataFrame({\"date\": s})\ndf.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n</code></pre> Parameters:     series: The pandas Series object the extension is attached to.</p> <p>Attributes:</p> Name Type Description <code>_series</code> <code>T</code> <p>The pandas Series object the extension is attached to.</p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>@pl.api.register_series_namespace(\"iwd\")\n@pl.api.register_expr_namespace(\"iwd\")\nclass SeriesIsoWeek(Generic[T]):\n    \"\"\"Polars Series and Expr extension that provides methods for working with ISO weeks and dates.\n\n    Instead of importing and working with single functions from the `polars_utils` module, it is possible to import the\n    Series and Expr [extension class](https://pola-rs.github.io/polars/py-polars/html/reference/api.html) to be able to\n    use the functions as methods on Series and Expr objects.\n\n    To accomplish this, it is enough to load `SeriesIsoWeek` into scope:\n\n    ```python hl_lines=\"3 6 9\"\n    from datetime import date, timedelta\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n    s.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\n    df = pl.DataFrame({\"date\": s})\n    df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n    ```\n    Parameters:\n        series: The pandas Series object the extension is attached to.\n\n    Attributes:\n        _series: The pandas Series object the extension is attached to.\n    \"\"\"\n\n    def __init__(self: Self, series: T) -&gt; None:\n        self._series: T = series\n\n    def datetime_to_isoweek(self: Self, offset: OffsetType = timedelta(0)) -&gt; T:\n        \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week format YYYY-WNN.\n\n        Arguments:\n            offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                ISO Week, it can be negative\n\n        Returns:\n            Series or Expr with converted ISO Week values (in format YYYY-WNN)\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n\n        Examples:\n        ```py\n        from datetime import date, timedelta\n\n        import polars as pl\n        from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n        s.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\n        df = pl.DataFrame({\"date\": s})\n        df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n        ```\n        \"\"\"\n        return datetime_to_isoweek(self._series, offset=offset)\n\n    def datetime_to_isoweekdate(self: Self, offset: OffsetType = timedelta(0)) -&gt; T:\n        \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week date format YYYY-WNN-D.\n\n        Arguments:\n            offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                ISO Week, it can be negative\n\n        Returns:\n            Series or Expr with converted ISO Week values (in format YYYY-WNN-D)\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n\n        Examples:\n        ```py\n        from datetime import date, timedelta\n\n        import polars as pl\n        from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n        s.iwd.datetime_to_isoweekdate(offset=timedelta(days=1))\n\n        df = pl.DataFrame({\"date\": s})\n        df.select(pl.col(\"date\").iwd.datetime_to_isoweekdate(offset=1))\n        ```\n        \"\"\"\n        return datetime_to_isoweekdate(self._series, offset=offset)\n\n    def isoweek_to_datetime(\n        self: Self,\n        offset: OffsetType = timedelta(0),\n        weekday: int = 1,\n        *,\n        strict: bool = True,\n    ) -&gt; T:\n        \"\"\"Converts series or expr of `str` values in ISO Week format YYYY-WNN to a series or expr of `pl.Date` values.\n\n        `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n        `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n        week, 7 is the last one.\n\n        Arguments:\n            offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            weekday: Weekday to use for conversion (1-7).\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series or Expr of converted date values\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n            ValueError: If `weekday` is not an integer between 1 and 7\n\n        Examples:\n        ```py\n        from datetime import timedelta\n\n        import polars as pl\n        from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        s.iwd.isoweek_to_datetime(offset=timedelta(days=1))\n        '''\n        date\n        2022-12-27\n        2023-01-03\n        2023-01-10\n        '''\n        ```\n        \"\"\"\n        return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)\n\n    def isoweekdate_to_datetime(self: Self, offset: OffsetType = timedelta(0), *, strict: bool = True) -&gt; T:\n        \"\"\"Converts `str` series or expr of ISO Week date format YYYY-WNN-D to a series or expr of `pl.Date` values.\n\n        `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n        Arguments:\n            offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series or Expr of converted date values\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n\n        Examples:\n        ```py\n        from datetime import timedelta\n\n        import polars as pl\n        from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n        s.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))\n        '''\n        date\n        2022-01-02\n        2023-01-03\n        2023-01-10\n        '''\n        ```\n        \"\"\"\n        return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)\n\n    def is_isoweek(self: Self) -&gt; bool:\n        \"\"\"Checks if a series or expr contains only values in ISO Week format.\n\n        Returns:\n            `True` if all values match ISO Week format, `False` otherwise\n\n        Examples:\n        ```py\n        import polars as pl\n        from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        s.iwd.is_isoweek() # True\n        ```\n        \"\"\"\n        return is_isoweek_series(self._series)\n\n    def is_isoweekdate(self: Self) -&gt; bool:\n        \"\"\"Checks if a series or expr contains only values in ISO Week date format.\n\n        Returns:\n            `True` if all values match ISO Week date format, `False` otherwise\n\n        Examples:\n        ```py\n        import polars as pl\n        from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n        s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        s.iwd.is_isoweekdate()  # True\n        ```\n        \"\"\"\n        return is_isoweekdate_series(self._series)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.datetime_to_isoweek","title":"<code>datetime_to_isoweek(offset=timedelta(0))</code>","text":"<p>Converts <code>date(time)</code> <code>series/expr</code> to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(0)</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <p>Examples: <pre><code>from datetime import date, timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ns.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\ndf = pl.DataFrame({\"date\": s})\ndf.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweek(self: Self, offset: OffsetType = timedelta(0)) -&gt; T:\n    \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN)\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date, timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n    s.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\n    df = pl.DataFrame({\"date\": s})\n    df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n    ```\n    \"\"\"\n    return datetime_to_isoweek(self._series, offset=offset)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.datetime_to_isoweekdate","title":"<code>datetime_to_isoweekdate(offset=timedelta(0))</code>","text":"<p>Converts <code>date(time)</code> <code>series/expr</code> to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(0)</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN-D)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <p>Examples: <pre><code>from datetime import date, timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ns.iwd.datetime_to_isoweekdate(offset=timedelta(days=1))\n\ndf = pl.DataFrame({\"date\": s})\ndf.select(pl.col(\"date\").iwd.datetime_to_isoweekdate(offset=1))\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweekdate(self: Self, offset: OffsetType = timedelta(0)) -&gt; T:\n    \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN-D)\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import date, timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n    s.iwd.datetime_to_isoweekdate(offset=timedelta(days=1))\n\n    df = pl.DataFrame({\"date\": s})\n    df.select(pl.col(\"date\").iwd.datetime_to_isoweekdate(offset=1))\n    ```\n    \"\"\"\n    return datetime_to_isoweekdate(self._series, offset=offset)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.is_isoweek","title":"<code>is_isoweek()</code>","text":"<p>Checks if a series or expr contains only values in ISO Week format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Examples: <pre><code>import polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\ns.iwd.is_isoweek() # True\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweek(self: Self) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week format.\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Examples:\n    ```py\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    s.iwd.is_isoweek() # True\n    ```\n    \"\"\"\n    return is_isoweek_series(self._series)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.is_isoweekdate","title":"<code>is_isoweekdate()</code>","text":"<p>Checks if a series or expr contains only values in ISO Week date format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Examples: <pre><code>import polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\ns.iwd.is_isoweekdate()  # True\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweekdate(self: Self) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week date format.\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Examples:\n    ```py\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n    s.iwd.is_isoweekdate()  # True\n    ```\n    \"\"\"\n    return is_isoweekdate_series(self._series)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.isoweek_to_datetime","title":"<code>isoweek_to_datetime(offset=timedelta(0), weekday=1, *, strict=True)</code>","text":"<p>Converts series or expr of <code>str</code> values in ISO Week format YYYY-WNN to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>timedelta(0)</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7).</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples: <pre><code>from datetime import timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\ns.iwd.isoweek_to_datetime(offset=timedelta(days=1))\n'''\ndate\n2022-12-27\n2023-01-03\n2023-01-10\n'''\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweek_to_datetime(\n    self: Self,\n    offset: OffsetType = timedelta(0),\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; T:\n    \"\"\"Converts series or expr of `str` values in ISO Week format YYYY-WNN to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7).\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n    ```py\n    from datetime import timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n    s.iwd.isoweek_to_datetime(offset=timedelta(days=1))\n    '''\n    date\n    2022-12-27\n    2023-01-03\n    2023-01-10\n    '''\n    ```\n    \"\"\"\n    return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.isoweekdate_to_datetime","title":"<code>isoweekdate_to_datetime(offset=timedelta(0), *, strict=True)</code>","text":"<p>Converts <code>str</code> series or expr of ISO Week date format YYYY-WNN-D to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>timedelta(0)</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <p>Examples: <pre><code>from datetime import timedelta\n\nimport polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\ns.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))\n'''\ndate\n2022-01-02\n2023-01-03\n2023-01-10\n'''\n</code></pre></p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweekdate_to_datetime(self: Self, offset: OffsetType = timedelta(0), *, strict: bool = True) -&gt; T:\n    \"\"\"Converts `str` series or expr of ISO Week date format YYYY-WNN-D to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    Arguments:\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n\n    Examples:\n    ```py\n    from datetime import timedelta\n\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n    s.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))\n    '''\n    date\n    2022-01-02\n    2023-01-03\n    2023-01-10\n    '''\n    ```\n    \"\"\"\n    return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)\n</code></pre>"},{"location":"api/pydantic/","title":"Pydantic Types","text":"<p>Pydantic model compatible types, implementation follows pydantic documentation at: Customizing validation with <code>__get_pydantic_core_schema__</code> and it requires <code>pydantic&gt;=2.4.0</code>.</p>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeek","title":"<code>iso_week_date.pydantic.T_ISOWeek</code>","text":"<p>             Bases: <code>str</code></p> <p>T_ISOWeek parses iso week in the ISO 8601 format.</p> <p>New in version 1.2.0</p> <p>Examples: <pre><code>from pydantic import BaseModel\nfrom iso_week_date.pydantic import T_ISOWeek\n\nclass Model(BaseModel):\n    isoweek: T_ISOWeek\n\nmodel = Model(isoweek=\"2024-W01\")\nprint(model)\n# isoweek='2024-W01'\n\n_ = Model(isoweek=\"2024-W53\")\n# ValidationError: 1 validation error for Model\n# isoweek\n#   Invalid week number. Year 2024 has only 52 weeks. [type=T_ISOWeek, input_value='2024-W53', input_type=str]\n\n_ = Model(isoweek=\"abc\")\n# ValidationError: 1 validation error for Model\n# isoweek\n#   Invalid iso week pattern [type=T_ISOWeek, input_value='abc', input_type=str]\n</code></pre></p> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>class T_ISOWeek(str):  # noqa: N801\n    \"\"\"T_ISOWeek parses iso week in the [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date) format.\n\n    !!! info \"New in version 1.2.0\"\n\n    Examples:\n    ```py\n    from pydantic import BaseModel\n    from iso_week_date.pydantic import T_ISOWeek\n\n    class Model(BaseModel):\n        isoweek: T_ISOWeek\n\n    model = Model(isoweek=\"2024-W01\")\n    print(model)\n    # isoweek='2024-W01'\n\n    _ = Model(isoweek=\"2024-W53\")\n    # ValidationError: 1 validation error for Model\n    # isoweek\n    #   Invalid week number. Year 2024 has only 52 weeks. [type=T_ISOWeek, input_value='2024-W53', input_type=str]\n\n    _ = Model(isoweek=\"abc\")\n    # ValidationError: 1 validation error for Model\n    # isoweek\n    #   Invalid iso week pattern [type=T_ISOWeek, input_value='abc', input_type=str]\n    ```\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: Type[Self],\n        source: Type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Return a Pydantic CoreSchema with the IsoWeek pattern validation.\n\n        Arguments:\n            source: The source type to be converted.\n            handler: The handler to get the CoreSchema.\n\n        Returns:\n            A Pydantic CoreSchema with the IsoWeek pattern validation.\n        \"\"\"\n        return core_schema.with_info_before_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n        )\n\n    @classmethod\n    def _validate(cls: Type[Self], __input_value: str, _: core_schema.ValidationInfo) -&gt; Self:\n        \"\"\"Validates iso week string format against ISOWEEK_PATTERN.\"\"\"\n        _match = re.match(ISOWEEK_PATTERN, __input_value)\n\n        if not _match:\n            raise PydanticCustomError(\"T_ISOWeek\", \"Invalid iso week pattern\")\n\n        year, week = int(_match.group(1)), int(_match.group(2)[1:])\n\n        if weeks_of_year(year) &lt; week:\n            raise PydanticCustomError(\n                \"T_ISOWeek\",\n                f\"Invalid week number. Year {year} has only {weeks_of_year(year)} weeks.\",\n            )\n\n        return cls(__input_value)\n</code></pre>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeek.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source, handler)</code>  <code>classmethod</code>","text":"<p>Return a Pydantic CoreSchema with the IsoWeek pattern validation.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Type[Any]</code> <p>The source type to be converted.</p> required <code>handler</code> <code>GetCoreSchemaHandler</code> <p>The handler to get the CoreSchema.</p> required <p>Returns:</p> Type Description <code>CoreSchema</code> <p>A Pydantic CoreSchema with the IsoWeek pattern validation.</p> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: Type[Self],\n    source: Type[Any],\n    handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Return a Pydantic CoreSchema with the IsoWeek pattern validation.\n\n    Arguments:\n        source: The source type to be converted.\n        handler: The handler to get the CoreSchema.\n\n    Returns:\n        A Pydantic CoreSchema with the IsoWeek pattern validation.\n    \"\"\"\n    return core_schema.with_info_before_validator_function(\n        cls._validate,\n        core_schema.str_schema(),\n    )\n</code></pre>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeekDate","title":"<code>iso_week_date.pydantic.T_ISOWeekDate</code>","text":"<p>             Bases: <code>str</code></p> <p>T_ISOWeekDate parses iso week date in the ISO 8601 format.</p> <p>New in version 1.2.0</p> <p>Examples: <pre><code>from pydantic import BaseModel\nfrom iso_week_date.pydantic import T_ISOWeekDate\n\nclass Model(BaseModel):\n    isoweekdate: T_ISOWeekDate\n\nmodel = Model(isoweekdate=\"2024-W01-1\")\nprint(model)\n# isoweekdate='2024-W01-1'\n\n_ = Model(isoweekdate=\"2024-W53-1\")\n# ValidationError: 1 validation error for Model\n# isoweekdate\n#   Invalid week number. Year 2024 has only 52 weeks.\n#   [type=type=T_ISOWeekDate, input_value='2024-W53-1', input_type=str]\n\n_ = Model(isoweekdate=\"abc\")\n# ValidationError: 1 validation error for Model\n# isoweekdate\n#   Invalid iso week pattern [type=type=T_ISOWeekDate, input_value='abc', input_type=str]\n</code></pre></p> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>class T_ISOWeekDate(str):  # noqa: N801\n    \"\"\"T_ISOWeekDate parses iso week date in the [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date) format.\n\n    !!! info \"New in version 1.2.0\"\n\n    Examples:\n    ```py\n    from pydantic import BaseModel\n    from iso_week_date.pydantic import T_ISOWeekDate\n\n    class Model(BaseModel):\n        isoweekdate: T_ISOWeekDate\n\n    model = Model(isoweekdate=\"2024-W01-1\")\n    print(model)\n    # isoweekdate='2024-W01-1'\n\n    _ = Model(isoweekdate=\"2024-W53-1\")\n    # ValidationError: 1 validation error for Model\n    # isoweekdate\n    #   Invalid week number. Year 2024 has only 52 weeks.\n    #   [type=type=T_ISOWeekDate, input_value='2024-W53-1', input_type=str]\n\n    _ = Model(isoweekdate=\"abc\")\n    # ValidationError: 1 validation error for Model\n    # isoweekdate\n    #   Invalid iso week pattern [type=type=T_ISOWeekDate, input_value='abc', input_type=str]\n    ```\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: Type[Self],\n        source: Type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Return a Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n        Arguments:\n            source: The source type to be converted.\n            handler: The handler to get the CoreSchema.\n\n        Returns:\n            A Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n        \"\"\"\n        return core_schema.with_info_before_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n        )\n\n    @classmethod\n    def _validate(cls: Type[Self], __input_value: str, _: core_schema.ValidationInfo) -&gt; Self:\n        \"\"\"Validates iso week date string format against ISOWEEKDATE_PATTERN.\"\"\"\n        _match = re.match(ISOWEEKDATE_PATTERN, __input_value)\n\n        if not _match:\n            raise PydanticCustomError(\"T_ISOWeekDate\", \"Invalid iso week date pattern\")\n\n        year, week = int(_match.group(1)), int(_match.group(2)[1:])\n\n        if weeks_of_year(year) &lt; week:\n            raise PydanticCustomError(\n                \"T_ISOWeekDate\",\n                f\"Invalid week number. Year {year} has only {weeks_of_year(year)} weeks.\",\n            )\n\n        return cls(__input_value)\n</code></pre>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeekDate.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source, handler)</code>  <code>classmethod</code>","text":"<p>Return a Pydantic CoreSchema with the IsoWeekDate pattern validation.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Type[Any]</code> <p>The source type to be converted.</p> required <code>handler</code> <code>GetCoreSchemaHandler</code> <p>The handler to get the CoreSchema.</p> required <p>Returns:</p> Type Description <code>CoreSchema</code> <p>A Pydantic CoreSchema with the IsoWeekDate pattern validation.</p> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: Type[Self],\n    source: Type[Any],\n    handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Return a Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n    Arguments:\n        source: The source type to be converted.\n        handler: The handler to get the CoreSchema.\n\n    Returns:\n        A Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n    \"\"\"\n    return core_schema.with_info_before_validator_function(\n        cls._validate,\n        core_schema.str_schema(),\n    )\n</code></pre>"},{"location":"user-guide/dataframe-modules/","title":"Dataframe modules","text":"<p>The <code>pandas_utils</code> and <code>polars_utils</code> modules provide the same API to work with <code>pandas.Series</code> and <code>polars.Series</code>/<code>polars.Expr</code> respectively.</p> <p>The utilities come in two flavors: functions and extensions.</p>"},{"location":"user-guide/dataframe-modules/#functions","title":"Functions","text":"<p>The functions approach takes the series/expr as an argument and returns a new series/expr.</p> <p>Available functions are:</p> <ul> <li><code>datetime_to_isoweek</code> and <code>datetime_to_isoweekdate</code>: converts a <code>datetime</code> series to an ISO week (date) series.</li> <li><code>isoweek_to_datetime</code> and <code>isoweekdate_to_datetime</code>: converts an ISO week date series to a <code>datetime</code> series.</li> <li><code>is_isoweek_series</code> and <code>is_isoweekdate_series</code>: checks if a series is an ISO week (date) series.</li> </ul> pandas<pre><code>import pandas as pd\nfrom datetime import date, timedelta\nfrom iso_week_date.pandas_utils import datetime_to_isoweek, isoweek_to_datetime, is_isoweek_series\n\ns_date = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ndatetime_to_isoweek(series=s_date, offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n\ns_iso = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\nisoweek_to_datetime(series=s_iso, offset=pd.Timedelta(days=1))\n'''\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n'''\n\nis_isoweek_series(s_iso)  # True\nis_isoweek_series(s_iso + \"abc\")  # False\n</code></pre> polars<pre><code>import polars as pl\nfrom datetime import date, timedelta\nfrom iso_week_date.polars_utils import datetime_to_isoweekdate, isoweekdate_to_datetime, is_isoweekdate_series\n\ns_date = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\", eager=True)\ndatetime_to_isoweekdate(s_date, offset=timedelta(days=1)).to_list()\n# ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n\ns_iso = pl.Series([\"2022-W52-1\", \"2023-W01-2\", \"2023-W02-7\"])\nisoweekdate_to_datetime(series=s_iso,offset=timedelta(days=1))\n'''\ndate\n2022-12-27\n2023-01-04\n2023-01-16\n'''\n\nis_isoweekdate_series(s_iso)  # True\nis_isoweekdate_series(s_iso + \"abc\")  # False\n</code></pre>"},{"location":"user-guide/dataframe-modules/#extensions","title":"Extensions","text":"<p>On the other hand the extensions<sup>1</sup> approach extends the <code>pandas.Series</code> and <code>polars.Series</code>/<code>polars.Expr</code> classes with new methods.</p> <p>The extensions are available through the <code>iwd</code> (isoweekdate) namespace, and the methods available are the same as the functions.</p> <p>\"Translating\" the previous examples to extensions:</p> pandas<pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401 (1)\n\ns_date = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ns_date.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n\ns_iso = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\ns_iso.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n'''\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n'''\n\ns_iso.iwd.is_isoweek(s_iso)  # True\ns_iso.iwd.is_isoweek(s_iso + \"abc\")  # False\n</code></pre> <ol> <li> <p>The import of <code>SeriesIsoWeek</code> is needed to register the extensions.</p> <p>noqa: F401 is added to avoid the linter(s) warning about the unused import.</p> </li> </ol> polars<pre><code>import polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401 (1)\n\ns_date = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ns_date.iwd.datetime_to_isoweekdate(offset=timedelta(days=1)).to_list()\n# ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n\ns_iso = pl.Series([\"2022-W52-1\", \"2023-W01-2\", \"2023-W02-7\"])\ns_iso.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))\n'''\ndate\n2022-12-27\n2023-01-04\n2023-01-16\n'''\n\ns_iso.iwd.is_isoweekdate()  # True\n(s_iso + \"abc\").iwd.is_isoweekdate_series()  # False\n</code></pre> <ol> <li> <p>The import of <code>SeriesIsoWeek</code> is needed to register the extensions.</p> <p>noqa: F401 is added to avoid the linter(s) warning about the unused import.</p> </li> </ol> <p>Note</p> <p>Polars extension is valid for both <code>Series</code> and <code>Expr</code> classes.</p> <p>This means that it is possible to use the extension in any polars context in which it would be possible to use an expression.</p> <ol> <li> <p>Extending pandas and polars \u21a9</p> </li> </ol>"},{"location":"user-guide/features/","title":"Features","text":"<p>This is a high level overview of the features provided by the <code>iso-week-date</code> package.</p>"},{"location":"user-guide/features/#isoweek-and-isoweekdate-classes","title":"<code>IsoWeek</code> and <code>IsoWeekDate</code> classes","text":"<p>The <code>IsoWeek</code> and <code>IsoWeekDate</code> classes both provide the following functionalities:</p> <ul> <li>Parsing from string, date and datetime objects</li> <li>Conversion to string, date and datetime objects</li> <li>Comparison operations between <code>IsoWeek</code> (resp <code>IsoWeekDate</code>) objects</li> <li>Addition with <code>int</code>, <code>timedelta</code>, and  <code>Iterable[int | timedelta]</code> types</li> <li>Subtraction with <code>int</code>, <code>timedelta</code>, <code>IsoWeek</code> (resp <code>IsoWeekDate</code>), and <code>Iterable[int | timedelta | IsoWeek]</code> types</li> <li>Range between two <code>IsoWeek</code> (resp. <code>IsoWeekDate</code>) objects</li> <li><code>__next__</code> method to generate the next <code>IsoWeek</code> (resp. <code>IsoWeekDate</code>) object</li> </ul> <p><code>IsoWeek</code> unique methods/features:</p> <ul> <li><code>days</code> properties that lists the dates in the given week</li> <li><code>nth</code> method to get the nth day of the week as date</li> <li><code>in</code> operator and <code>contains</code> method to check if a (iterable of) week(s), string(s) and/or date(s) is contained in the given week</li> <li><code>weeksout</code> method to generate a list of weeks that are n_weeks after the given week</li> <li>Addition and subtraction with <code>int</code> defaults to adding/subtracting weeks</li> </ul> <p><code>IsoWeekDate</code> unique methods/features:</p> <ul> <li><code>day</code> property that returns the weekday as integer</li> <li><code>isoweek</code> property that returns the ISO Week of the given date (as string)</li> <li><code>daysout</code> method to generate a list of dates that are n_days after the given date</li> <li>Addition and subtraction with <code>int</code> defaults to adding/subtracting days</li> </ul>"},{"location":"user-guide/features/#pandas-and-polars-utils","title":"pandas and polars utils","text":"<p><code>pandas_utils</code> and <code>polars_utils</code> modules provide functionalities to work with and move back and forth with series of ISO Week date formats.</p> <p>In specific both modules implements the following functionalities:</p> <ul> <li><code>datetime_to_isoweek</code> and <code>datetime_to_isoweekdate</code> to convert a series of datetime objects to a series of ISO Week (date) strings</li> <li><code>isoweek_to_datetime</code> and <code>isoweekdate_to_datetime</code> to convert a series of ISO Week (date) strings to a series of datetime objects</li> <li><code>is_isoweek_series</code> and <code>is_isoweekdate_series</code> to check if a string series values match the ISO Week (date) format</li> </ul>"},{"location":"user-guide/features/#custom-offset","title":"Custom offset","text":"<p>One of the main reason for this library to exist is the need and the flexibility to work with custom offsets, i.e. to be able to add/subtract a custom offset (as <code>timedelta</code>) to the default ISO Week start and given date, and get a \"shifted\" week.</p> <p>This feature is available both in the <code>IsoWeek</code> and <code>IsoWeekDate</code> classes and the dataframe functionalities.</p> <p>To check an example see the working with custom offset section.</p>"},{"location":"user-guide/internals/","title":"Internals","text":""},{"location":"user-guide/internals/#baseisoweek","title":"<code>BaseIsoWeek</code>","text":"<p><code>BaseIsoWeek</code> is an abstract base class that provides:</p> <ul> <li>Template for functionalities that need to be implemented the shared functionalities to work with ISO Week date in different formats.</li> </ul> <p>It is not meant to be used directly, but it is the base class for both <code>IsoWeek</code> and <code>IsoWeekDate</code> classes.</p> <p>The functionalities provided by the <code>BaseIsoWeek</code> class directly are:</p> <ul> <li>Validation method(s) to check if a string matches a certain format/pattern</li> <li><code>range</code> method to generate a range between a start and end isoweek(date)s.</li> <li>Properties such as <code>year</code> and <code>week</code> to access the year and week number of the instance as <code>int</code>.</li> </ul> <p>Other functionalities are provided by mean of Mixin's:</p> <ul> <li>Parsing methods (<code>from_string</code>, <code>from_compact</code>, <code>from_date</code>, <code>from_datetime</code>) (via <code>ParserMixin</code>)</li> <li>Conversion methods (<code>to_string</code>, <code>to_compact</code>, <code>to_date</code>, <code>to_datetime</code>) (via <code>ConverterMixin</code>)</li> <li>All the comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) (via <code>ComparatorMixin</code>)</li> </ul>"},{"location":"user-guide/pydantic/","title":"Working with Pydantic","text":"<p>If you want to work with ISO Week (date) format within pydantic v2, i.e. create a model with a string field representing an ISO Week (date) format, there are two options: the easy way and the hard proper way.</p>"},{"location":"user-guide/pydantic/#the-easy-way","title":"The easy way","text":"<p>The easy way to achieve this is via <code>Annotated</code> and <code>StringConstraints</code> with custom regex patterns.</p> <p>The regex patterns are available in the top level module of iso-week-date, therefore it is possible to use them directly:</p> <pre><code>from typing import Annotated\n\nfrom iso_week_date import ISOWEEK_PATTERN, ISOWEEKDATE_PATTERN\nfrom pydantic import BaseModel, StringConstraints\n\nT_ISOWeek = Annotated[str, StringConstraints(pattern=ISOWEEK_PATTERN.pattern)]\nT_ISOWeekDate = Annotated[str, StringConstraints(pattern=ISOWEEKDATE_PATTERN.pattern)]\n\nclass MyModel(BaseModel):\n    week: T_ISOWeek\n    week_date: T_ISOWeekDate\n\nm1 = MyModel(week='2023-W01', week_date='2023-W01-1')\nm2 = MyModel(week='2023-W53', week_date='2023-W01-1')\n</code></pre>"},{"location":"user-guide/pydantic/#caveat","title":"Caveat","text":"<p>The caveat of this approach can be seen in the second instance in the example above. Namely the regex patterns could be not strict enough for your purpouses, i.e. they allow for some combinations that are not valid ISO Week (date) formats.</p> <p>In fact not every combination of year and week number should be possible (not every year has 53 weeks!), but this is not enforced by the regex patterns.</p> <p>Note</p> <p>Remark that actual validation happens when instantiating <code>IsoWeek</code> and <code>IsoWeekDate</code> classes.</p> <p>On the positive side, python datetime module deals with that automagically:</p> <pre><code>from datetime import datetime\n\n# 2023 has 52 weeks\ndatetime.strptime(\"2023-W53-1\", \"%G-W%V-%u\")  # datetime(2024, 1, 1, 0, 0)\ndatetime.strptime(\"2024-W01-1\", \"%G-W%V-%u\")  # datetime(2024, 1, 1, 0, 0)\n</code></pre> <p>As we can see the datetime module is able to parse both <code>2023-W53-1</code> and <code>2024-W01-1</code> as the same datetime object (<code>datetime(2024, 1, 1, 0, 0)</code>).</p>"},{"location":"user-guide/pydantic/#the-proper-way","title":"The proper way","text":"<p>As of iso-week-date version 1.2.0, we provide a <code>.pydantic</code> submodule, which implements <code>T_ISOWeek</code> and <code>T_ISOWeekDate</code> custom types using custom validation with <code>__get_pydantic_core_schema__</code>.</p> <p>Such implementation requires pydantic v2.4.0+ and pydantic-core features, which are under fast and active development.</p> <pre><code>from iso_week_date.pydantic import T_ISOWeek, T_ISOWeekDate\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    week: T_ISOWeek\n    week_date: T_ISOWeekDate\n\nm1 = MyModel(week='2023-W01', week_date='2023-W01-1')  # All good here!\nm2 = MyModel(week='2023-W53', week_date='2023-W01-1')  # Raises ValidationError\n</code></pre> <pre><code>ValidationError: 1 validation error for MyModel\nweek\n  Invalid week number. Year 2023 has only 52 weeks. [type=T_ISOWeek, input_value='2023-W53', input_type=str]\n</code></pre>"},{"location":"user-guide/pydantic/#compact-formats","title":"Compact formats","text":"<p>The compact formats (YYYYWNN, YYYYWNND) are not directly available in the module. However if needed it is possible to composed them with some gymnastic:</p> <pre><code>from typing import Final\nfrom iso_week_date._patterns import YEAR_MATCH, WEEK_MATCH, WEEKDAY_MATCH  # These are strings, not regex patterns\n\nISOWEEK_COMPACT_PATTERN: Final[str] = r\"^{}{}$\".format(YEAR_MATCH, WEEK_MATCH)\nISOWEEKDATE_COMPACT_PATTERN: Final[str] = r\"^{}{}{}$\".format(YEAR_MATCH, WEEK_MATCH, WEEK_DAY_MATCH)\n\nT_ISOWeekCompact = Annotated[str, StringConstraints(pattern=ISOWEEK_COMPACT_PATTERN)]\nT_ISOWeekDateCompact = Annotated[str, StringConstraints(pattern=ISOWEEKDATE_COMPACT_PATTERN)]\n</code></pre>"},{"location":"user-guide/quickstart/","title":"Quickstart","text":"<p>In this section we will see how to work with the different modules of the library.</p> <p>For a high level overview of the features provided by the <code>iso-week-date</code> package, see the features section.</p> <p>For a detailed description of the API, see the API Reference section.</p>"},{"location":"user-guide/quickstart/#common-functionalities","title":"Common functionalities","text":"<p>As mentioned in the features section, the <code>IsoWeek</code> and <code>IsoWeekDate</code> classes share a lot of functionalities and methods, since they both inherit from the same abstract base class, namely <code>BaseIsoWeek</code>.</p> <p>Therefore we will focus first on the common functionalities, and then showcase the unique features of each class.</p> <p>Both these classes are available from the top-level module:</p> imports<pre><code>from iso_week_date import IsoWeek, IsoWeekDate\nfrom datetime import date, datetime, timedelta\n</code></pre>"},{"location":"user-guide/quickstart/#parsing-from-types","title":"Parsing from types","text":"<p>An instance can be initialized from parsing multiple types:</p> directly<code>from_string</code><code>from_compact</code><code>from_date</code><code>from_datetime</code><code>from_values</code> <pre><code>iw = IsoWeek(\"2023-W01\")  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate(\"2023-W01-1\")  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_string(\"2023-W01\")  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_string(\"2023-W01-1\")  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_compact(\"2023W01\")  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_compact(\"2023W01-1\")  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_date(date(2023, 1, 2))  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_date(date(2023, 1, 2))  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_datetime(datetime(2023, 1, 2, 12))  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_datetime(datetime(2023, 1, 2, 12))  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_values(year=2023, week=1)  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_values(2023, 1, weekday=1)  # IsoWeekDate(\"2023-W01-1\")\n</code></pre>"},{"location":"user-guide/quickstart/#conversion-to-types","title":"Conversion to types","text":"<p>On the \"opposite\" direction, an instance can be converted to multiple types:</p> <code>to_string</code><code>to_compact</code><code>to_date</code><code>to_datetime</code><code>to_values</code> <pre><code>iw.to_string()  # \"2023-W01\"\niwd.to_string()  # \"2023-W01-1\"\n</code></pre> <pre><code>iw.to_compact()  # \"2023W01\"\niwd.to_compact()  # \"2023W011\"\n</code></pre> <pre><code>iw.to_date()  # date(2023, 1, 2)\niwd.to_date()  # date(2023, 1, 2)\n</code></pre> <pre><code>iw.to_datetime()  # datetime(2023, 1, 2, 0, 0)\niwd.to_datetime()  # datetime(2023, 1, 2, 0, 0)\n</code></pre> <pre><code>iw.to_values()  # (2023, 1)  # (year, weeknumber)\niwd.to_values()  # (2023, 1, 1)  # (year, weeknumber, weekday)\n</code></pre> <p>IsoWeek to date/datetime</p> <p>Remark that <code>IsoWeek.to_date</code> and <code>IsoWeek.to_datetime</code> methods accept an optional <code>weekday</code> argument, which defaults to <code>1</code> (first weekday), and can be used to get the date of a specific day of the week:</p> specific weekday<pre><code>iw.to_date(2)  # date(2023, 1, 3)\niw.to_datetime(3)  # datetime(2023, 1, 4, 0, 0)\n</code></pre>"},{"location":"user-guide/quickstart/#comparison-operations","title":"Comparison operations","text":"<p>Both classes inherit all the comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>), which can be used to compare two instances of the same class:</p> <pre><code>iw == IsoWeek(\"2023-W01\") # True\niw == iwd # False\niw &lt; IsoWeek(\"2023-W02\") # True\niwd &gt; IsoWeekDate(\"2023-W02-2\") # False\niw &lt; iwd # TypeError\n</code></pre> <p>To compare two instances we first check that they have the same parent class, then check they share the same offset value, and finally we compare their string value exploiting the lexical order of the ISO Week date format.</p>"},{"location":"user-guide/quickstart/#properties","title":"Properties","text":"<code>year</code><code>week</code> <pre><code>iw.year  # 2023\niwd.year  # 2023\n</code></pre> <pre><code>iw.week  # 1\niwd.week  # 1\n</code></pre>"},{"location":"user-guide/quickstart/#addition-and-subtraction","title":"Addition and subtraction","text":"<p>Classes inheriting from <code>BaseIsoWeek</code> have to implement:</p> <ul> <li>addition with <code>int</code> and <code>timedelta</code> types</li> <li> <p>subtraction with <code>int</code>, <code>timedelta</code> and <code>Self</code> types (1)</p> <ol> <li>The <code>Self</code> type is the class itself, i.e. <code>IsoWeek</code> for <code>IsoWeek</code> and <code>IsoWeekDate</code> for <code>IsoWeekDate</code>.</li> </ol> </li> </ul> <p>operation with <code>int</code>s</p> <p>The two classes treat <code>int</code> type differently when performing addition and subtraction operations. Namely:</p> <ul> <li>For <code>IsoWeek</code> it is interpreted as weeks</li> <li>For <code>IsoWeekDate</code> it is interpreted as days</li> </ul> Addition <code>+</code>Subtraction <code>-</code> <pre><code>iw + 1  # IsoWeek(\"2023-W02\")\niw + timedelta(weeks=2)  # IsoWeek(\"2023-W03\")\n\ntuple(iw + (1,2,3))  # (IsoWeek(\"2023-W02\"), IsoWeek(\"2023-W03\"), IsoWeek(\"2023-W04\"))\n\niwd + 1  # IsoWeekDate(\"2023-W01-2\")\niwd + timedelta(days=2)  # IsoWeekDate(\"2023-W01-3\")\n</code></pre> <pre><code>iw - 1  # IsoWeek(\"2022-W52\")\niw - timedelta(weeks=2)  # IsoWeek(\"2022-W51\")\niw - IsoWeek(\"2022-W52\")  # 1\n\ntuple(iw - (1,2,3))  # (IsoWeek(\"2022-W52\"), IsoWeek(\"2022-W51\"), IsoWeek(\"2022-W50\"))\n\niwd - 1 # IsoWeekDate(\"2022-W52-7\")\niwd - timedelta(days=2) # IsoWeekDate(\"2022-W52-6\")\niwd - IsoWeekDate(\"2022-W52-3\") # 5\n</code></pre>"},{"location":"user-guide/quickstart/#range-method","title":"Range method","text":"<p><code>BaseIsoWeek</code> implements a classmethod to create range between two \"ISO Week\"-like objects that inherit from it and implement addition with <code>int</code> and subtraction between ISO Week objects.</p> range classmethod<pre><code>tuple(IsoWeek.range(start=\"2023-W01\", end=\"2023-W07\", step=2, inclusive=\"both\", as_str=True))\n# ('2023-W01', '2023-W03', '2023-W05', '2023-W07')\n\ntuple(IsoWeekDate.range(start=\"2023-W01-1\", end=\"2023-W03-3\", step=3, inclusive=\"left\", as_str=True))\n# ('2023-W01-1', '2023-W01-4', '2023-W01-7', '2023-W02-3', '2023-W02-6', '2023-W03-2')\n</code></pre>"},{"location":"user-guide/quickstart/#isoweek-specific","title":"<code>IsoWeek</code> specific","text":"<p>In addition to the common functionalities, the <code>IsoWeek</code> class provides additional properties and methods.</p>"},{"location":"user-guide/quickstart/#days-property","title":"Days property","text":"<p>The <code>days</code> property returns a tuple of <code>date</code>s in the given week:</p> <pre><code>iw.days # (date(2023, 1, 2), date(2023, 1, 3), ..., date(2023, 1, 8))\n</code></pre>"},{"location":"user-guide/quickstart/#weeksout-method","title":"Weeksout method","text":"<p>The <code>weeksout</code> method generates a list of weeks that are n_weeks after the given week:</p> <pre><code>tuple(iw.weeksout(3)) # ('2023-W02', '2023-W03', '2023-W04')\ntuple(iw.weeksout(6, step=2, as_str=False)) # (IsoWeek('2023-W02'), IsoWeek('2023-W04'), IsoWeek('2023-W06'))\n</code></pre>"},{"location":"user-guide/quickstart/#contains-method","title":"Contains method","text":"<p>The <code>contains</code> method checks if a (iterable of) week(s), string(s) and/or date(s) is contained in the given week:</p> <pre><code>iw.contains(\"2023-W01\") # True\niw.contains(date(2023, 1, 1)) # False\n\niw.contains((IsoWeek(\"2023-W01\"), date(2023, 1, 1), date(2023, 1, 2))) # (True, False, True)\n</code></pre> <p>This is achieved by implementing the <code>__contains__</code> method, which is called when using the <code>in</code> operator:</p> <pre><code>date(2023, 1, 1) in iw # False\ndate(2023, 1, 2) in iw # True\n</code></pre>"},{"location":"user-guide/quickstart/#isoweekdate-specific","title":"<code>IsoWeekDate</code> specific","text":"<p>In a similar fashion, <code>IsoWeekDate</code> class provides additional properties and methods.</p>"},{"location":"user-guide/quickstart/#properties_1","title":"Properties","text":"<p>We have two additional properties:</p> <ul> <li><code>isoweek</code> returns the ISO Week of the given date (as string)</li> <li><code>day</code>: returns the weekday as integer</li> </ul> <code>isoweek</code><code>day</code> <pre><code>iwd.isoweek  # \"2023-W01\"\n</code></pre> <pre><code>iwd.day  # 1\n</code></pre>"},{"location":"user-guide/quickstart/#daysout-method","title":"Daysout method","text":"<p>The <code>daysout</code> method generates a list of dates that are n_days after the given date:</p> <pre><code>tuple(iwd.daysout(3)) # ('2023-W01-2', '2023-W01-3', '2023-W01-4')\ntuple(iwd.daysout(6, step=3, as_str=False))\n# (IsoWeekDate('2023-W01-2'), IsoWeekDate('2023-W01-5'), IsoWeekDate('2023-W02-1'))\n</code></pre>"},{"location":"user-guide/quickstart/#working-with-custom-offset","title":"Working with custom offset","text":"<p>The \"standard\" ISO Week starts on Monday and end on Sunday. However there are cases in which one may require a shift in the starting day of a week.</p> <p>The <code>IsoWeek</code> class has one class attribute called <code>offset_</code> which can be used to define a custom offset for the week.</p> custom offset<pre><code>class MyWeek(IsoWeek):\n    \"\"\"\n    MyWeek class is a IsoWeek with custom offset of -2 days.\n    Therefore MyWeek starts the Saturday before the \"standard\" ISO week.\n    \"\"\"\n    offset_ = timedelta(days=-2)\n</code></pre> <p>This is all that is required to work with a custom shifted week.</p> <p>Now the same date may be \"mapped\" to different ISO Weeks depending on the offset:</p> <pre><code>_date = date(2023, 1, 1)\nIsoWeek.from_date(_date)  # IsoWeek(2022-W52)\nMyWeek.from_date(_date)  # MyWeek(2023-W01)\n</code></pre> <p>Or we can see that the same week starts on different dates:</p> <pre><code>IsoWeek(\"2023-W01\").nth(1)  # date(2023, 1, 2)\nMyWeek(\"2023-W01\").nth(1)  # date(2022, 12, 31)\n</code></pre> <p>Similarly we can define a custom offset for the <code>IsoWeekDate</code> class:</p> custom offset<pre><code>class MyWeekDate(IsoWeekDate):\n    \"\"\"\n    MyWeekDate class is a IsoWeekDate with custom offset of -2 days.\n    Therefore MyWeekDate starts the Saturday before the \"standard\" ISO week.\n    \"\"\"\n    offset_ = timedelta(days=-2)\n</code></pre> <p>All the functionalities still work as expected, just keep in mind that comparisons and arithmetic operations will be available only on instances with the same offset.</p>"}]}